/**
 * @module @zk-kit/lean-imt
 * @version 2.0.1
 * @file Lean Incremental Merkle tree implementation in TypeScript.
 * @copyright Ethereum Foundation 2024
 * @license MIT
 * @see [Github]{@link https://github.com/privacy-scaling-explorations/zk-kit/tree/main/packages/lean-imt}
*/
var zkKitLeanImt=function(e){"use strict";
/**
     * @module @zk-kit/utils
     * @version 1.0.0
     * @file Essential zero-knowledge utility library for JavaScript developers.
     * @copyright Ethereum Foundation 2024
     * @license MIT
     * @see [Github]{@link https://github.com/privacy-scaling-explorations/zk-kit/tree/main/packages/utils}
    */
/**
     * @module @zk-kit/utils
     * @version 1.0.0
     * @file Essential zero-knowledge utility library for JavaScript developers.
     * @copyright Ethereum Foundation 2024
     * @license MIT
     * @see [Github]{@link https://github.com/privacy-scaling-explorations/zk-kit/tree/main/packages/utils}
    */
function t(e,t){if(void 0===e)throw new TypeError(`Parameter '${t}' is not defined`)}function s(e,t){if("number"!=typeof e)throw new TypeError(`Parameter '${t}' is not a number, received type: ${typeof e}`)}function i(e,t){if(!function(e){return"object"==typeof e}(s=e)||!Array.isArray(s))throw new TypeError(`Parameter '${t}' is not an Array instance`);var s}class r{constructor(e,s=[]){t(e,"hash"),function(e,t){if("function"!=typeof e)throw new TypeError(`Parameter '${t}' is not a function, received type: ${typeof e}`)}(e,"hash"),i(s,"leaves"),this._nodes=[[]],this._hash=e,s.length>0&&this.insertMany(s)}get root(){return this._nodes[this.depth][0]}get depth(){return this._nodes.length-1}get leaves(){return this._nodes[0].slice()}get size(){return this._nodes[0].length}indexOf(e){return t(e,"leaf"),this._nodes[0].indexOf(e)}has(e){return t(e,"leaf"),this._nodes[0].includes(e)}insert(e){t(e,"leaf"),this.depth<Math.ceil(Math.log2(this.size+1))&&this._nodes.push([]);let s=e,i=this.size;for(let e=0;e<this.depth;e+=1){if(this._nodes[e][i]=s,1&i){const t=this._nodes[e][i-1];s=this._hash(t,s)}i>>=1}this._nodes[this.depth]=[s]}insertMany(e){if(t(e,"leaves"),i(e,"leaves"),0===e.length)throw new Error("There are no leaves to add");let s=this.size>>1;this._nodes[0].push(...e);const r=Math.ceil(Math.log2(this.size))-this.depth;for(let e=0;e<r;e+=1)this._nodes.push([]);for(let e=0;e<this.depth;e+=1){const t=Math.ceil(this._nodes[e].length/2);for(let i=s;i<t;i+=1){const t=this._nodes[e][2*i+1],s=this._nodes[e][2*i],r=t?this._hash(s,t):s;this._nodes[e+1][i]=r}s>>=1}}update(e,i){t(e,"index"),t(i,"newLeaf"),s(e,"index");let r=i;for(let t=0;t<this.depth;t+=1){if(this._nodes[t][e]=r,1&e){const s=this._nodes[t][e-1];r=this._hash(s,r)}else{const s=this._nodes[t][e+1];s&&(r=this._hash(r,s))}e>>=1}this._nodes[this.depth]=[r]}generateProof(e){if(t(e,"index"),s(e,"index"),e<0||e>=this.size)throw new Error(`The leaf at index '${e}' does not exist in this tree`);const i=this.leaves[e],r=[],n=[];for(let t=0;t<this.depth;t+=1){const s=1&e,i=s?e-1:e+1,o=this._nodes[t][i];void 0!==o&&(n.push(s),r.push(o)),e>>=1}return{root:this.root,leaf:i,index:Number.parseInt(n.reverse().join(""),2),siblings:r}}verifyProof(e){return r.verifyProof(e,this._hash)}static verifyProof(e,r){t(e,"proof");const{root:n,leaf:o,siblings:h,index:a}=e;t(e.root,"proof.root"),t(e.leaf,"proof.leaf"),t(e.siblings,"proof.siblings"),t(e.index,"proof.index"),i(e.siblings,"proof.siblings"),s(e.index,"proof.index");let d=o;for(let e=0;e<h.length;e+=1)d=a>>e&1?r(h[e],d):r(d,h[e]);return n===d}export(){return JSON.stringify(this._nodes,((e,t)=>"bigint"==typeof t?t.toString():t))}import(e){if(t(e,"nodes"),function(e,t){if("string"!=typeof e)throw new TypeError(`Parameter '${t}' is not a string, received type: ${typeof e}`)}(e,"nodes"),0!==this.size)throw new Error("Import failed: the target tree structure is not empty");this._nodes=JSON.parse(e)}}return e.LeanIMT=r,e}({});
