import { EdDSAPCD } from "@pcd/eddsa-pcd";
import { ObjectArgument, PCD, StringArgument } from "@pcd/pcd-types";
/**
 * The globally unique type name of the {@link EdDSATicketPCD}.
 */
export declare const EdDSATicketPCDTypeName = "eddsa-ticket-pcd";
/**
 * Assigns each currently supported category a unique value.
 */
export declare enum TicketCategory {
    ZuConnect = 0,
    Devconnect = 1,
    PcdWorkingGroup = 2,
    Zuzalu = 3,
    Generic = 4
}
/**
 * The ticket data here is based on passport-server's ticket data model,
 * which is in turn based on the data model from Pretix.
 *
 * In this model, a Ticket represents the purchase of a Product, which is
 * associated with an Event.
 *
 * Events may have many Products, such as subsidized tickets, sponsor tickets,
 * organizer tickets, or time-restricted passes. A given Product can only be
 * associated with one Event.
 *
 * In general, consumers of this data will want to be aware of both the event
 * ID and product ID. If providing a service that should be accessible to
 * ticket-holders for an event, and using this PCD as proof of ticket-holding,
 * the consumer should check that both the event ID and product ID match a
 * list of known ticket types, and that the public key (in `proof.eddsaPCD`)
 * matches the public key of the known issuer of the tickets.
 *
 * An example of how this might be done is shown in {@link verifyTicket} in
 * passport-server's issuance service, which is requested by passport-client
 * when verifying tickets.
 */
export interface ITicketData {
    eventName: string;
    ticketName: string;
    checkerEmail?: string | undefined;
    imageUrl?: string | undefined;
    imageAltText?: string | undefined;
    ticketId: string;
    eventId: string;
    productId: string;
    timestampConsumed: number;
    timestampSigned: number;
    attendeeSemaphoreId: string;
    isConsumed: boolean;
    isRevoked: boolean;
    ticketCategory: TicketCategory;
    attendeeName: string;
    attendeeEmail: string;
}
/**
 * Defines the essential parameters required for creating an {@link EdDSATicketPCD}.
 */
export type EdDSATicketPCDArgs = {
    /**
     * The EdDSA private key is a 32-byte value used to sign the message.
     * {@link newEdDSAPrivateKey} is recommended for generating highly secure private keys.
     */
    privateKey: StringArgument;
    /**
     * A {@link ITicketData} object containing ticket information that is encoded into this PCD.
     */
    ticket: ObjectArgument<ITicketData>;
    /**
     * A string that uniquely identifies an {@link EdDSATicketPCD}. If this argument is not specified a random
     * id will be generated.
     */
    id: StringArgument;
};
/**
 * Defines the EdDSA Ticket PCD claim. The claim contains a ticket that was signed
 * with the private key corresponding to the given public key stored in the proof.
 */
export interface EdDSATicketPCDClaim {
    ticket: ITicketData;
}
/**
 * Defines the EdDSA Ticket PCD proof. The proof is an EdDSA PCD whose message
 * is the encoded ticket.
 */
export interface EdDSATicketPCDProof {
    eddsaPCD: EdDSAPCD;
}
/**
 * The EdDSA Ticket PCD enables the verification that a specific ticket ({@link EdDSATicketPCDClaim})
 * has been signed with an EdDSA private key. The {@link EdDSATicketPCDProof} contains a EdDSA
 * PCD and serves as the signature.
 */
export declare class EdDSATicketPCD implements PCD<EdDSATicketPCDClaim, EdDSATicketPCDProof> {
    type: string;
    claim: EdDSATicketPCDClaim;
    proof: EdDSATicketPCDProof;
    id: string;
    constructor(id: string, claim: EdDSATicketPCDClaim, proof: EdDSATicketPCDProof);
}
/**
 * Returns true if a PCD is an EdDSA Ticket PCD, or false otherwise.
 */
export declare function isEdDSATicketPCD(pcd: PCD): pcd is EdDSATicketPCD;
/**
 * Throws if {@link pcd} is not an {@link EdDSATicketPCD}.
 */
export declare function expectIsEdDSATicketPCD(pcd: PCD): asserts pcd is EdDSATicketPCD;
//# sourceMappingURL=EdDSATicketPCD.d.ts.map