"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SemaphoreGroupPCDPackage = exports.getDisplayOptions = exports.deserialize = exports.serialize = exports.verify = exports.prove = exports.init = void 0;
const semaphore_identity_pcd_1 = require("@pcd/semaphore-identity-pcd");
const semaphore_signature_pcd_1 = require("@pcd/semaphore-signature-pcd");
const util_1 = require("@pcd/util");
const proof_1 = require("@semaphore-protocol/proof");
const json_bigint_1 = __importDefault(require("json-bigint"));
const uuid_1 = require("uuid");
const SemaphoreGroupPCD_1 = require("./SemaphoreGroupPCD");
const SerializedSemaphoreGroup_1 = require("./SerializedSemaphoreGroup");
let initArgs = undefined;
async function init(args) {
    initArgs = args;
}
exports.init = init;
async function prove(args) {
    if (!initArgs) {
        throw new Error("Cannot make group proof: init has not been called yet");
    }
    const serializedIdentityPCD = args.identity.value?.pcd;
    if (!serializedIdentityPCD) {
        throw new Error("Cannot make group proof: missing semaphore identity PCD");
    }
    const identityPCD = await semaphore_identity_pcd_1.SemaphoreIdentityPCDPackage.deserialize(serializedIdentityPCD);
    const serializedGroup = args.group.value;
    if (!serializedGroup) {
        throw new Error("Cannot make group proof: missing semaphore group");
    }
    if (!args.externalNullifier.value) {
        throw new Error("Cannot make group proof: missing externalNullifier");
    }
    if (!args.signal.value) {
        throw new Error("Cannot make group proof: missing signal");
    }
    // Restrict the SemaphoreGroupPCD from having the same externalNullifier as the
    // SemaphoreSignaturePCD. The nullifierHash in a SemaphoreGroupPCD is supposed
    // to be a unique string that is one-to-one with a specific member of the group,
    // but unlinkable to any specific member. However, if an adversarial SemaphoreGroupPCD
    // is set up with the same externalNullifier as the SemaphoreSignaturePCD, then the
    // outputted nullifierHash for a user will be the same as the nullifierHash outputted
    // from the same user's SemaphoreSignaturePCD. Thus, an adversary could link a
    // nullifierHash back to a user if they also have access to a signature from them,
    // which is unintended behavior that would break their anonymity.
    if (BigInt(args.externalNullifier.value) === semaphore_signature_pcd_1.STATIC_SIGNATURE_PCD_NULLIFIER) {
        throw new Error("Cannot make group proof: same externalNullifier as SemaphoreSignaturePCD, which would break anonymity");
    }
    const deserializedGroup = (0, SerializedSemaphoreGroup_1.deserializeSemaphoreGroup)(serializedGroup);
    const fullProof = await (0, proof_1.generateProof)(identityPCD.claim.identity, deserializedGroup, args.externalNullifier.value, args.signal.value, {
        zkeyFilePath: initArgs.zkeyFilePath,
        wasmFilePath: initArgs.wasmFilePath
    });
    const claim = {
        merkleRoot: deserializedGroup.root.toString(),
        depth: deserializedGroup.depth,
        externalNullifier: args.externalNullifier.value.toString(),
        nullifierHash: fullProof.nullifierHash.toString(),
        signal: args.signal.value.toString()
    };
    const proof = fullProof.proof;
    return new SemaphoreGroupPCD_1.SemaphoreGroupPCD((0, uuid_1.v4)(), claim, proof);
}
exports.prove = prove;
async function verify(pcd) {
    const fullProof = {
        externalNullifier: pcd.claim.externalNullifier,
        merkleTreeRoot: pcd.claim.merkleRoot + "",
        nullifierHash: pcd.claim.nullifierHash,
        signal: pcd.claim.signal,
        proof: pcd.proof
    };
    const valid = await (0, proof_1.verifyProof)(fullProof, pcd.claim.depth);
    return valid;
}
exports.verify = verify;
async function serialize(pcd) {
    return {
        type: SemaphoreGroupPCD_1.SemaphoreGroupPCDTypeName,
        pcd: (0, json_bigint_1.default)().stringify(pcd)
    };
}
exports.serialize = serialize;
async function deserialize(serialized) {
    const { id, claim, proof } = (0, json_bigint_1.default)().parse(serialized);
    (0, util_1.requireDefinedParameter)(id, "id");
    (0, util_1.requireDefinedParameter)(claim, "claim");
    (0, util_1.requireDefinedParameter)(proof, "proof");
    return new SemaphoreGroupPCD_1.SemaphoreGroupPCD(id, claim, proof);
}
exports.deserialize = deserialize;
function getDisplayOptions(pcd) {
    return {
        header: "Semaphore Group Signal",
        displayName: "semaphore-group-" + pcd.id.substring(0, 4)
    };
}
exports.getDisplayOptions = getDisplayOptions;
/**
 * PCD-conforming wrapper for the Semaphore zero-knowledge protocol. You can
 * find documentation of Semaphore here: https://semaphore.appliedzkp.org/docs/introduction
 */
exports.SemaphoreGroupPCDPackage = {
    name: SemaphoreGroupPCD_1.SemaphoreGroupPCDTypeName,
    getDisplayOptions,
    init,
    prove,
    verify,
    serialize,
    deserialize
};
