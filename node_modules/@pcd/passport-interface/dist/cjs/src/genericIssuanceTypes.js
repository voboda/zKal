"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PipelineDefinitionSchema = exports.isCSVPipelineDefinition = exports.CSVPipelineOutputType = exports.isPretixPipelineDefinition = exports.UserPermissionsOptionsSchema = exports.AutoIssuanceOptionsSchema = exports.isLemonadePipelineDefinition = exports.ContactsConfigSchema = exports.BadgesConfigSchema = exports.BadgeConfigSchema = exports.ActionScreenConfigSchema = exports.MemberCriteriaSchema = exports.IncidentPolicy = exports.PipelineType = void 0;
const zod_1 = require("zod");
/**
 * Each new {@link Pipeline} type needs a corresponding entry in thie enum.
 */
var PipelineType;
(function (PipelineType) {
    PipelineType["Lemonade"] = "Lemonade";
    PipelineType["Pretix"] = "Pretix";
    PipelineType["CSV"] = "CSV";
})(PipelineType || (exports.PipelineType = PipelineType = {}));
var IncidentPolicy;
(function (IncidentPolicy) {
    IncidentPolicy["Everyone"] = "Everyone";
    IncidentPolicy["JustIvan"] = "JustIvan";
    IncidentPolicy["JustRichard"] = "JustRichard";
})(IncidentPolicy || (exports.IncidentPolicy = IncidentPolicy = {}));
const BasePipelineDefinitionSchema = zod_1.z.object({
    id: zod_1.z.string().uuid(),
    ownerUserId: zod_1.z.string().uuid(),
    editorUserIds: zod_1.z.array(zod_1.z.string().uuid()),
    timeCreated: zod_1.z.string(),
    timeUpdated: zod_1.z.string()
});
const AlertsOptionsSchema = zod_1.z.object({
    pagerduty: zod_1.z.boolean().optional(),
    loadIncidentPagePolicy: zod_1.z.nativeEnum(IncidentPolicy).optional(),
    discordTags: zod_1.z.array(zod_1.z.string()).optional(),
    discordAlerts: zod_1.z.boolean().optional(),
    alertOnLogErrors: zod_1.z.boolean().optional(),
    errorLogIgnoreRegexes: zod_1.z.array(zod_1.z.string()).optional(),
    alertOnLogWarnings: zod_1.z.boolean().optional(),
    warningLogIgnoreRegexes: zod_1.z.array(zod_1.z.string()).optional(),
    alertOnAtomMismatch: zod_1.z.boolean().optional()
});
const BasePipelineOptionsSchema = zod_1.z.object({
    /**
     * Paused pipelines don't load data, but their APIs are still
     * accessible and enabled.
     */
    paused: zod_1.z.boolean().optional(),
    name: zod_1.z.string().optional(),
    notes: zod_1.z.string().optional(),
    alerts: AlertsOptionsSchema.optional(),
    /**
     * Protected pipelines can't be deleted.
     */
    protected: zod_1.z.boolean().optional(),
    important: zod_1.z.boolean().optional()
});
/**
 * Pipeline definitions can also include manually-added tickets. Pipelines that
 * support this will create tickets according to these specifications, in
 * addition to those loaded from their primary data source.
 */
const ManualTicketSchema = zod_1.z.object({
    /**
     * The ID of the ticket.
     */
    id: zod_1.z.string().uuid(),
    /**
     * The generic issuance UUID of the event that the ticket is for.
     */
    eventId: zod_1.z.string().uuid(),
    /**
     * The generic issuance UUID for the product/ticket type.
     */
    productId: zod_1.z.string().uuid(),
    /**
     * The email to assign the ticket to.
     */
    attendeeEmail: zod_1.z.string().email(),
    /**
     * The full name of the attendee.
     */
    attendeeName: zod_1.z.string().min(1),
    timeCreated: zod_1.z.string().optional()
});
const ManualTicketListSchema = zod_1.z
    .array(ManualTicketSchema)
    .optional()
    .refine((manualTickets) => 
// If manualTickets is undefined then that's OK
manualTickets === undefined ||
    // Otherwise make sure each one has a unique ID
    manualTickets.length ===
        new Set(manualTickets.map((manualTicket) => manualTicket.id)).size, { message: "Ticket IDs must be unique" });
const LemonadePipelineTicketTypeConfigSchema = zod_1.z.object({
    /**
     * The ID of this ticket type on the Lemonade end.
     */
    externalId: zod_1.z.string(),
    /**
     * The UUID of this ticket type used in {@link EdDSATicketPCD}.
     */
    genericIssuanceProductId: zod_1.z.string().uuid(),
    /**
     * Whether this ticket type is allowed to check other tickets in or not.
     */
    isSuperUser: zod_1.z.boolean(),
    /**
     * Display name
     */
    name: zod_1.z.string()
});
exports.MemberCriteriaSchema = zod_1.z.object({
    /**
     * generic issuance event id
     */
    eventId: zod_1.z.string().uuid(),
    /**
     * generic issuance product id
     */
    productId: zod_1.z.string().uuid().optional()
});
const SemaphoreGroupConfigSchema = zod_1.z.object({
    /**
     * Defines the set of event ID/product ID pairs that qualify a ticket-holder
     * for membership in this group. If no product ID is specified, then all
     * tickets for the event will qualify for group membership.
     *
     * The groupId is a UUID which the administrator should generate.
     */
    groupId: zod_1.z.string().uuid(),
    name: zod_1.z.string().min(1),
    memberCriteria: zod_1.z.array(exports.MemberCriteriaSchema)
});
const SemaphoreGroupListSchema = zod_1.z
    .array(SemaphoreGroupConfigSchema)
    .optional()
    .refine((groups) => 
// Groups being undefined is valid
groups === undefined ||
    // If groups are defined, the number of unique IDs must equal the
    // number of groups
    groups.length === new Set(groups.map((group) => group.groupId)).size, { message: "Semaphore group IDs must be unique" })
    .refine((groups) => 
// Groups being undefined is valid
groups === undefined ||
    // If groups are defined, the number of unique names must equal the
    // number of groups
    groups.length === new Set(groups.map((group) => group.name)).size, { message: "Semaphore group names must be unique" });
const LemonadePipelineEventConfigSchema = zod_1.z.object({
    /**
     * The ID of this event on the Lemonade end.
     */
    externalId: zod_1.z.string(),
    /**
     * Display name.
     */
    name: zod_1.z.string(),
    /**
     * The UUID of this event used for {@link EdDSATicketPCD}.
     */
    genericIssuanceEventId: zod_1.z.string().uuid(),
    /**
     * Roughly translates to Products in {@link EdDSATicketPCD}.
     */
    ticketTypes: zod_1.z.array(LemonadePipelineTicketTypeConfigSchema)
});
exports.ActionScreenConfigSchema = zod_1.z.object({
    eventBannerUrl: zod_1.z.string().optional(),
    eventNameConfig: zod_1.z.string().optional()
});
exports.BadgeConfigSchema = zod_1.z.object({
    id: zod_1.z.string(),
    eventName: zod_1.z.string(),
    productName: zod_1.z.string().optional(),
    imageUrl: zod_1.z.string(),
    givers: zod_1.z.array(zod_1.z.string()).optional(),
    grantOnCheckin: zod_1.z.boolean().optional(),
    maxPerDay: zod_1.z.number().optional()
});
exports.BadgesConfigSchema = zod_1.z.object({
    enabled: zod_1.z.boolean().optional(),
    choices: zod_1.z.array(exports.BadgeConfigSchema).optional()
});
exports.ContactsConfigSchema = zod_1.z.object({
    enabled: zod_1.z.boolean().optional()
});
/**
 * Configuration of actions Podbox enables subscribers of the same Pipeline
 * to perform on each other:
 * - checking in
 * - issuing 'badges'
 * - pushing a contact card to scanee's zupass
 * - potentially other actions, like throwing snowballs.
 */
const TicketActionsOptionsSchema = zod_1.z.object({
    badges: exports.BadgesConfigSchema.optional(),
    contacts: exports.ContactsConfigSchema.optional(),
    screenConfig: exports.ActionScreenConfigSchema.optional()
});
const FeedIssuanceOptionsSchema = zod_1.z.object({
    feedId: zod_1.z.string(),
    feedDisplayName: zod_1.z.string(),
    feedDescription: zod_1.z.string(),
    feedFolder: zod_1.z.string()
});
const ImageOptionsSchema = zod_1.z.object({
    imageUrl: zod_1.z.string(),
    requireCheckedIn: zod_1.z.boolean()
});
const LemonadePipelineOptionsSchema = BasePipelineOptionsSchema.extend({
    /**
     * Configured by the user when setting up Lemonade as a data source.
     */
    oauthAudience: zod_1.z.string(),
    oauthClientId: zod_1.z.string(),
    oauthClientSecret: zod_1.z.string(),
    oauthServerUrl: zod_1.z.string(),
    backendUrl: zod_1.z.string(),
    events: zod_1.z.array(LemonadePipelineEventConfigSchema),
    superuserEmails: zod_1.z.array(zod_1.z.string()).optional(),
    feedOptions: FeedIssuanceOptionsSchema,
    manualTickets: ManualTicketListSchema,
    ticketActions: TicketActionsOptionsSchema.optional(),
    semaphoreGroups: SemaphoreGroupListSchema,
    enablePODTickets: zod_1.z.boolean().optional()
}).refine((val) => {
    // Validate that the manual tickets have event and product IDs that match the
    // event configuration.
    const events = new Map(val.events.map((ev) => [ev.genericIssuanceEventId, ev]));
    for (const manualTicket of val.manualTickets ?? []) {
        // Check that the event exists
        const manualTicketEvent = events.get(manualTicket.eventId);
        if (!manualTicketEvent) {
            return false;
        }
        // Check that the event has a product with the product ID on the ticket
        if (!manualTicketEvent.ticketTypes.find((ticketType) => ticketType.genericIssuanceProductId === manualTicket.productId)) {
            return false;
        }
    }
    return true;
});
const LemonadePipelineDefinitionSchema = BasePipelineDefinitionSchema.extend({
    type: zod_1.z.literal(PipelineType.Lemonade),
    options: LemonadePipelineOptionsSchema
});
function isLemonadePipelineDefinition(d) {
    return d.type === PipelineType.Lemonade;
}
exports.isLemonadePipelineDefinition = isLemonadePipelineDefinition;
const PretixProductConfigSchema = zod_1.z.object({
    /**
     * Pretix's item ID
     */
    externalId: zod_1.z.string(),
    /**
     * Our UUID
     */
    genericIssuanceId: zod_1.z.string().uuid(),
    /**
     * Display name
     */
    name: zod_1.z.string(),
    /**
     * Is a user with this product a "superuser"?
     * Superusers are able to check tickets in to events.
     */
    isSuperUser: zod_1.z.boolean(),
    /**
     * If the attendee's name is collected by a question
     * other than the default attendee name question, this
     * field lets you configure Podbox to prefer to read
     * names from answers to the question with this `question_identifier`
     *
     * see pretix docs here: https://docs.pretix.eu/en/latest/api/resources/orders.html#order-position-resource
     */
    nameQuestionPretixQuestionIdentitifier: zod_1.z.string().optional()
});
const PretixEventConfigSchema = zod_1.z.object({
    /**
     * Pretix's event ID
     */
    externalId: zod_1.z.string(),
    /**
     * Our UUID
     */
    genericIssuanceId: zod_1.z.string().uuid(),
    /**
     * Display name for the event
     */
    name: zod_1.z.string(),
    /**
     * Options to configure displaying an image instead of the QR code
     */
    imageOptions: ImageOptionsSchema.optional(),
    products: zod_1.z.array(PretixProductConfigSchema),
    /**
     * Skip validation of event settings - use with caution!
     */
    skipSettingsValidation: zod_1.z.boolean().optional()
});
exports.AutoIssuanceOptionsSchema = zod_1.z.object({
    memberCriteria: zod_1.z.array(exports.MemberCriteriaSchema),
    eventId: zod_1.z.string(),
    productId: zod_1.z.string(),
    quantity: zod_1.z.number(),
    schedule: zod_1.z.object({
        startDate: zod_1.z.string(),
        endDate: zod_1.z.string().optional(),
        intervalMs: zod_1.z.number()
    })
});
exports.UserPermissionsOptionsSchema = zod_1.z.object({
    members: zod_1.z.array(exports.MemberCriteriaSchema),
    canCheckIn: zod_1.z.object({
        eventId: zod_1.z.string(),
        productId: zod_1.z.string().optional()
    })
});
const PretixPipelineOptionsSchema = BasePipelineOptionsSchema.extend({
    /**
     * This object represents a configuration from which the server can instantiate
     * a functioning {@link PretixPipeline}. Partially specified by the user.
     */
    pretixAPIKey: zod_1.z.string(),
    pretixOrgUrl: zod_1.z.string(),
    events: zod_1.z.array(PretixEventConfigSchema),
    feedOptions: FeedIssuanceOptionsSchema,
    manualTickets: ManualTicketListSchema,
    semaphoreGroups: SemaphoreGroupListSchema,
    enablePODTickets: zod_1.z.boolean().optional(),
    autoIssuance: zod_1.z.array(exports.AutoIssuanceOptionsSchema).optional(),
    userPermissions: zod_1.z.array(exports.UserPermissionsOptionsSchema).optional()
}).refine((val) => {
    // Validate that the manual tickets have event and product IDs that match the
    // event configuration.
    const events = new Map(val.events.map((ev) => [ev.genericIssuanceId, ev]));
    for (const manualTicket of val.manualTickets ?? []) {
        // Check that the event exists
        const manualTicketEvent = events.get(manualTicket.eventId);
        if (!manualTicketEvent) {
            return false;
        }
        // Check that the event has a product with the product ID on the ticket
        if (!manualTicketEvent.products.find((product) => product.genericIssuanceId === manualTicket.productId)) {
            return false;
        }
    }
    return true;
});
const PretixPipelineDefinitionSchema = BasePipelineDefinitionSchema.extend({
    type: zod_1.z.literal(PipelineType.Pretix),
    options: PretixPipelineOptionsSchema
});
function isPretixPipelineDefinition(d) {
    return d.type === PipelineType.Pretix;
}
exports.isPretixPipelineDefinition = isPretixPipelineDefinition;
var CSVPipelineOutputType;
(function (CSVPipelineOutputType) {
    /**
     * {@link EdDSAMessagePCD}
     */
    CSVPipelineOutputType["Message"] = "EdDSAMessage";
    CSVPipelineOutputType["Ticket"] = "EdDSATicket";
    CSVPipelineOutputType["PODTicket"] = "PODTicketPCD";
})(CSVPipelineOutputType || (exports.CSVPipelineOutputType = CSVPipelineOutputType = {}));
const CSVPipelineOptionsSchema = BasePipelineOptionsSchema.extend({
    csv: zod_1.z.string(),
    outputType: zod_1.z.nativeEnum(CSVPipelineOutputType).optional(),
    feedOptions: FeedIssuanceOptionsSchema,
    issueToUnmatchedEmail: zod_1.z.boolean().optional()
});
const CSVPipelineDefinitionSchema = BasePipelineDefinitionSchema.extend({
    type: zod_1.z.literal(PipelineType.CSV),
    options: CSVPipelineOptionsSchema
});
function isCSVPipelineDefinition(d) {
    return d.type === PipelineType.CSV;
}
exports.isCSVPipelineDefinition = isCSVPipelineDefinition;
/**
 * This item is exported so that we can use it for validation on generic issuance server.
 */
exports.PipelineDefinitionSchema = zod_1.z.discriminatedUnion("type", [
    LemonadePipelineDefinitionSchema,
    PretixPipelineDefinitionSchema,
    CSVPipelineDefinitionSchema
]);
const PipelineHistoryEntrySchema = zod_1.z.object({
    id: zod_1.z.string().uuid(),
    pipeline: exports.PipelineDefinitionSchema,
    timeCreated: zod_1.z.string(),
    editorUserId: zod_1.z.string().optional()
});
