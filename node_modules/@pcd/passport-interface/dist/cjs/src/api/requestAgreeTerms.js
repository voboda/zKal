"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.agreeTerms = exports.requestAgreeTerms = void 0;
const pcd_types_1 = require("@pcd/pcd-types");
const semaphore_identity_pcd_1 = require("@pcd/semaphore-identity-pcd");
const semaphore_signature_pcd_1 = require("@pcd/semaphore-signature-pcd");
const makeRequest_1 = require("./makeRequest");
/**
 * Agrees to a given version of the legal terms.
 *
 * Never rejects. All information encoded in the resolved response.
 */
async function requestAgreeTerms(passportServerUrl, req) {
    return (0, makeRequest_1.httpPostSimple)(`${passportServerUrl}/account/agree-terms`, async (resText) => ({
        value: JSON.parse(resText),
        success: true
    }), req);
}
exports.requestAgreeTerms = requestAgreeTerms;
async function agreeTerms(zupassServerUrl, version, identity) {
    return requestAgreeTerms(zupassServerUrl, {
        // A generic authenticated route solution might make this much simpler
        pcd: await semaphore_signature_pcd_1.SemaphoreSignaturePCDPackage.serialize(await semaphore_signature_pcd_1.SemaphoreSignaturePCDPackage.prove({
            identity: {
                argumentType: pcd_types_1.ArgumentTypeName.PCD,
                value: await semaphore_identity_pcd_1.SemaphoreIdentityPCDPackage.serialize(await semaphore_identity_pcd_1.SemaphoreIdentityPCDPackage.prove({
                    identity
                }))
            },
            signedMessage: {
                argumentType: pcd_types_1.ArgumentTypeName.String,
                value: JSON.stringify({ version })
            }
        }))
    });
}
exports.agreeTerms = agreeTerms;
