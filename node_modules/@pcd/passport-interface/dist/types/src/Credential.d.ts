import { EdDSAPCDClaim } from "@pcd/eddsa-pcd";
import { EmailPCD, EmailPCDClaim } from "@pcd/email-pcd";
import { SerializedPCD } from "@pcd/pcd-types";
import { SemaphoreSignaturePCD, SemaphoreSignaturePCDClaim } from "@pcd/semaphore-signature-pcd";
export type Credential = SerializedPCD<SemaphoreSignaturePCD>;
export interface CredentialPayload {
    pcd?: SerializedPCD<EmailPCD>;
    timestamp: number;
}
/**
 * The result of successfully verifying a credential, as determined by
 * verifyCredential() below. To be verified, the credential must be wrapped in
 * a verifiable signature PCD, and must contain a payload that includes a
 * timestamp and an optional additional PCD (currently only EmailPCD is
 * supported for this purpose). The timestamp must be within certain bounds,
 * and the embedded PCD must be tied to the same identity that signed the
 * wrapper PCD.
 *
 * If the credential is verified, then this data is extracted from the claims
 * contained within it, and can be implicitly trusted without need for further
 * verification.
 *
 * We do not need to return whole PCDs here, because the proofs have been
 * verified, and since we expect to cache these in memory, we can avoid wasting
 * memory on caching large PCD objects.
 */
export interface VerifiedCredential {
    signatureClaim: SemaphoreSignaturePCDClaim;
    emailClaim?: EmailPCDClaim;
    emailSignatureClaim?: EdDSAPCDClaim;
}
/**
 * Creates a feed credential payload with timestamp.
 */
export declare function createCredentialPayload(pcd?: SerializedPCD<EmailPCD> | undefined): CredentialPayload;
export declare class VerificationError extends Error {
}
export declare function verifyCredential(credential: Credential): Promise<VerifiedCredential>;
//# sourceMappingURL=Credential.d.ts.map