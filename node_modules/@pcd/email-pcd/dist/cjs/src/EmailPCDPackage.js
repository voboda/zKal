"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EmailPCDPackage = exports.getDisplayOptions = exports.deserialize = exports.serialize = exports.verify = exports.prove = void 0;
const eddsa_pcd_1 = require("@pcd/eddsa-pcd");
const pcd_types_1 = require("@pcd/pcd-types");
const util_1 = require("@pcd/util");
const json_bigint_1 = __importDefault(require("json-bigint"));
const lodash_1 = __importDefault(require("lodash"));
const uuid_1 = require("uuid");
const EmailPCD_1 = require("./EmailPCD");
async function prove(args) {
    if (!args.privateKey.value) {
        throw new Error("missing private key");
    }
    if (!args.emailAddress.value) {
        throw new Error("missing email value");
    }
    if (!args.semaphoreId.value) {
        throw new Error("missing semaphore id");
    }
    // Hashes email and returns bigint representation of hash
    const hashedEmail = (0, util_1.generateSnarkMessageHash)(args.emailAddress.value);
    const eddsaPCD = await eddsa_pcd_1.EdDSAPCDPackage.prove({
        message: {
            value: [hashedEmail.toString(), args.semaphoreId.value],
            argumentType: pcd_types_1.ArgumentTypeName.StringArray
        },
        privateKey: {
            value: args.privateKey.value,
            argumentType: pcd_types_1.ArgumentTypeName.String
        },
        id: {
            value: args.id.value ? args.id.value + "-signature" : undefined,
            argumentType: pcd_types_1.ArgumentTypeName.String
        }
    });
    const id = args.id.value ?? (0, uuid_1.v4)();
    return new EmailPCD_1.EmailPCD(id, {
        emailAddress: args.emailAddress.value,
        semaphoreId: args.semaphoreId.value
    }, { eddsaPCD });
}
exports.prove = prove;
async function verify(pcd) {
    const messageDerivedFromClaim = (0, util_1.generateSnarkMessageHash)(pcd.claim.emailAddress);
    if (!lodash_1.default.isEqual([messageDerivedFromClaim, BigInt(pcd.claim.semaphoreId)], pcd.proof.eddsaPCD.claim.message)) {
        return false;
    }
    try {
        const valid = await eddsa_pcd_1.EdDSAPCDPackage.verify(pcd.proof.eddsaPCD);
        return valid;
    }
    catch (e) {
        return false;
    }
}
exports.verify = verify;
async function serialize(pcd) {
    const serializedEdDSAPCD = await eddsa_pcd_1.EdDSAPCDPackage.serialize(pcd.proof.eddsaPCD);
    return {
        type: EmailPCD_1.EmailPCDTypeName,
        pcd: (0, json_bigint_1.default)().stringify({
            id: pcd.id,
            eddsaPCD: serializedEdDSAPCD,
            emailAddress: pcd.claim.emailAddress,
            semaphoreId: pcd.claim.semaphoreId
        })
    };
}
exports.serialize = serialize;
async function deserialize(serialized) {
    const deserializedWrapper = (0, json_bigint_1.default)().parse(serialized);
    const deserializedEdDSAPCD = await eddsa_pcd_1.EdDSAPCDPackage.deserialize(deserializedWrapper.eddsaPCD.pcd);
    return new EmailPCD_1.EmailPCD(deserializedWrapper.id, {
        emailAddress: deserializedWrapper.emailAddress,
        semaphoreId: deserializedWrapper.semaphoreId
    }, { eddsaPCD: deserializedEdDSAPCD });
}
exports.deserialize = deserialize;
function getDisplayOptions(pcd) {
    return {
        header: "Verified email",
        displayName: pcd.claim.emailAddress
    };
}
exports.getDisplayOptions = getDisplayOptions;
/**
 * PCD-conforming wrapper to sign messages using an EdDSA keypair,
 * representing an attested email.
 */
exports.EmailPCDPackage = {
    name: EmailPCD_1.EmailPCDTypeName,
    getDisplayOptions,
    prove,
    verify,
    serialize,
    deserialize
};
