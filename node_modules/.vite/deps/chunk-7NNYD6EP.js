import {
  derived,
  readable,
  writable
} from "./chunk-ZDKSVB7X.js";
import {
  SvelteComponentDev,
  action_destroyer,
  add_location,
  afterUpdate,
  append_hydration_dev,
  attr_dev,
  beforeUpdate,
  check_outros,
  children,
  claim_component,
  claim_element,
  claim_space,
  claim_text,
  component_subscribe,
  construct_svelte_component_dev,
  create_component,
  destroy_component,
  destroy_each,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  ensure_array_like_dev,
  getContext,
  get_current_component,
  get_store_value,
  globals,
  group_outros,
  identity,
  init,
  insert_hydration_dev,
  is_function,
  listen_dev,
  mount_component,
  noop,
  prop_dev,
  run_all,
  safe_not_equal,
  setContext,
  set_data_dev,
  set_store_value,
  set_style,
  space,
  text,
  tick,
  transition_in,
  transition_out,
  validate_slots,
  validate_store
} from "./chunk-CBQLSORC.js";

// node_modules/@event-calendar/core/src/Calendar.svelte
import "/home/salim/repos/zucal/node_modules/@event-calendar/core/index.css";

// node_modules/@event-calendar/core/src/lib/a11y.js
function keyEnter(fn) {
  return function(e) {
    return e.key === "Enter" || e.key === " " && !e.preventDefault() ? fn.call(this, e) : void 0;
  };
}

// node_modules/@event-calendar/core/src/lib/actions.js
function setContent(node, content) {
  let actions = {
    update(content2) {
      if (typeof content2 == "string") {
        node.innerText = content2;
      } else if (content2 == null ? void 0 : content2.domNodes) {
        node.replaceChildren(...content2.domNodes);
      } else if (content2 == null ? void 0 : content2.html) {
        node.innerHTML = content2.html;
      }
    }
  };
  actions.update(content);
  return actions;
}
function outsideEvent(node, type) {
  const handlePointerDown = (jsEvent) => {
    if (node && !node.contains(jsEvent.target)) {
      node.dispatchEvent(
        new CustomEvent(type + "outside", { detail: { jsEvent } })
      );
    }
  };
  document.addEventListener(type, handlePointerDown, true);
  return {
    destroy() {
      document.removeEventListener(type, handlePointerDown, true);
    }
  };
}

// node_modules/@event-calendar/core/src/lib/date.js
var DAY_IN_SECONDS = 86400;
function createDate(input = void 0) {
  if (input !== void 0) {
    return input instanceof Date ? _fromLocalDate(input) : _fromISOString(input);
  }
  return _fromLocalDate(/* @__PURE__ */ new Date());
}
function createDuration(input) {
  if (typeof input === "number") {
    input = { seconds: input };
  } else if (typeof input === "string") {
    let seconds = 0, exp = 2;
    for (let part of input.split(":", 3)) {
      seconds += parseInt(part, 10) * Math.pow(60, exp--);
    }
    input = { seconds };
  } else if (input instanceof Date) {
    input = { hours: input.getUTCHours(), minutes: input.getUTCMinutes(), seconds: input.getUTCSeconds() };
  }
  let weeks = input.weeks || input.week || 0;
  return {
    years: input.years || input.year || 0,
    months: input.months || input.month || 0,
    days: weeks * 7 + (input.days || input.day || 0),
    seconds: (input.hours || input.hour || 0) * 60 * 60 + (input.minutes || input.minute || 0) * 60 + (input.seconds || input.second || 0),
    inWeeks: !!weeks
  };
}
function cloneDate(date) {
  return new Date(date.getTime());
}
function addDuration(date, duration, x = 1) {
  date.setUTCFullYear(date.getUTCFullYear() + x * duration.years);
  let month = date.getUTCMonth() + x * duration.months;
  date.setUTCMonth(month);
  month %= 12;
  if (month < 0) {
    month += 12;
  }
  while (date.getUTCMonth() !== month) {
    subtractDay(date);
  }
  date.setUTCDate(date.getUTCDate() + x * duration.days);
  date.setUTCSeconds(date.getUTCSeconds() + x * duration.seconds);
  return date;
}
function subtractDuration(date, duration, x = 1) {
  return addDuration(date, duration, -x);
}
function addDay(date, x = 1) {
  date.setUTCDate(date.getUTCDate() + x);
  return date;
}
function subtractDay(date, x = 1) {
  return addDay(date, -x);
}
function setMidnight(date) {
  date.setUTCHours(0, 0, 0, 0);
  return date;
}
function toLocalDate(date) {
  return new Date(
    date.getUTCFullYear(),
    date.getUTCMonth(),
    date.getUTCDate(),
    date.getUTCHours(),
    date.getUTCMinutes(),
    date.getUTCSeconds()
  );
}
function toISOString(date, len = 19) {
  return date.toISOString().substring(0, len);
}
function datesEqual(date1, ...dates2) {
  return dates2.every((date2) => date1.getTime() === date2.getTime());
}
function nextClosestDay(date, day) {
  let diff2 = day - date.getUTCDay();
  date.setUTCDate(date.getUTCDate() + (diff2 >= 0 ? diff2 : diff2 + 7));
  return date;
}
function prevClosestDay(date, day) {
  let diff2 = day - date.getUTCDay();
  date.setUTCDate(date.getUTCDate() + (diff2 <= 0 ? diff2 : diff2 - 7));
  return date;
}
function noTimePart(date) {
  return typeof date === "string" && date.length <= 10;
}
function copyTime(toDate, fromDate) {
  toDate.setUTCHours(fromDate.getUTCHours(), fromDate.getUTCMinutes(), fromDate.getUTCSeconds(), 0);
  return toDate;
}
function toSeconds(duration, defaultValue = 0) {
  return (duration == null ? void 0 : duration.seconds) ?? defaultValue;
}
function _fromLocalDate(date) {
  return new Date(Date.UTC(
    date.getFullYear(),
    date.getMonth(),
    date.getDate(),
    date.getHours(),
    date.getMinutes(),
    date.getSeconds()
  ));
}
function _fromISOString(str) {
  const parts = str.match(/\d+/g);
  return new Date(Date.UTC(
    Number(parts[0]),
    Number(parts[1]) - 1,
    Number(parts[2]),
    Number(parts[3] || 0),
    Number(parts[4] || 0),
    Number(parts[5] || 0)
  ));
}

// node_modules/@event-calendar/core/src/lib/debounce.js
function debounce(fn, handle, queueStore) {
  queueStore.update((queue) => queue.set(handle, fn));
}
function flushDebounce(queue) {
  run_all(queue);
  queue.clear();
}
function task(fn, handle, tasks) {
  handle ?? (handle = fn);
  if (!tasks.has(handle)) {
    tasks.set(handle, setTimeout(() => {
      tasks.delete(handle);
      fn();
    }));
  }
}

// node_modules/@event-calendar/core/src/lib/utils.js
function assign(...args) {
  return Object.assign(...args);
}
function keys(object) {
  return Object.keys(object);
}
function floor(value) {
  return Math.floor(value);
}
function ceil(value) {
  return Math.ceil(value);
}
function min(...args) {
  return Math.min(...args);
}
function max(...args) {
  return Math.max(...args);
}
function symbol() {
  return Symbol("ec");
}

// node_modules/@event-calendar/core/src/lib/dom.js
function createElement(tag, className, content, attrs = []) {
  let el = document.createElement(tag);
  el.className = className;
  if (typeof content == "string") {
    el.innerText = content;
  } else if (content.domNodes) {
    el.replaceChildren(...content.domNodes);
  } else if (content.html) {
    el.innerHTML = content.html;
  }
  for (let attr of attrs) {
    el.setAttribute(...attr);
  }
  return el;
}
function hasYScroll(el) {
  return el.scrollHeight > el.clientHeight;
}
function rect(el) {
  return el.getBoundingClientRect();
}
function ancestor(el, up) {
  while (up--) {
    el = el.parentElement;
  }
  return el;
}
function height(el) {
  return rect(el).height;
}
var payloadProp = symbol();
function setPayload(el, payload) {
  el[payloadProp] = payload;
}
function hasPayload(el) {
  return !!(el == null ? void 0 : el[payloadProp]);
}
function getPayload(el) {
  return el[payloadProp];
}
function getElementWithPayload(x, y, root = document) {
  for (let el of root.elementsFromPoint(x, y)) {
    if (hasPayload(el)) {
      return el;
    }
    if (el.shadowRoot) {
      let shadowEl = getElementWithPayload(x, y, el.shadowRoot);
      if (shadowEl) {
        return shadowEl;
      }
    }
  }
  return null;
}

// node_modules/@event-calendar/core/src/lib/view.js
function createView(view2, _viewTitle, _currentRange, _activeRange) {
  return {
    type: view2,
    title: _viewTitle,
    currentStart: _currentRange.start,
    currentEnd: _currentRange.end,
    activeStart: _activeRange.start,
    activeEnd: _activeRange.end,
    calendar: void 0
  };
}
function toViewWithLocalDates(view2) {
  view2 = assign({}, view2);
  view2.currentStart = toLocalDate(view2.currentStart);
  view2.currentEnd = toLocalDate(view2.currentEnd);
  view2.activeStart = toLocalDate(view2.activeStart);
  view2.activeEnd = toLocalDate(view2.activeEnd);
  return view2;
}
function listView(view2) {
  return view2.startsWith("list");
}
function timelineView(view2) {
  return view2.includes("Timeline");
}

// node_modules/@event-calendar/core/src/lib/events.js
var eventId = 1;
function createEvents(input) {
  return input.map((event) => {
    let result = {
      id: "id" in event ? String(event.id) : `{generated-${eventId++}}`,
      resourceIds: Array.isArray(event.resourceIds) ? event.resourceIds.map(String) : "resourceId" in event ? [String(event.resourceId)] : [],
      allDay: event.allDay ?? (noTimePart(event.start) && noTimePart(event.end)),
      start: createDate(event.start),
      end: createDate(event.end),
      title: event.title || "",
      titleHTML: event.titleHTML || "",
      editable: event.editable,
      startEditable: event.startEditable,
      durationEditable: event.durationEditable,
      display: event.display || "auto",
      extendedProps: event.extendedProps || {},
      backgroundColor: event.backgroundColor || event.color,
      textColor: event.textColor
    };
    if (result.allDay) {
      setMidnight(result.start);
      let end = cloneDate(result.end);
      setMidnight(result.end);
      if (!datesEqual(result.end, end) || datesEqual(result.end, result.start)) {
        addDay(result.end);
      }
    }
    return result;
  });
}
function createEventSources(input) {
  return input.map((source) => ({
    events: source.events,
    url: source.url && source.url.trimEnd("&") || "",
    method: source.method && source.method.toUpperCase() || "GET",
    extraParams: source.extraParams || {}
  }));
}
function createEventChunk(event, start, end) {
  return {
    start: event.start > start ? event.start : start,
    end: event.end < end ? event.end : end,
    event
  };
}
function sortEventChunks(chunks) {
  chunks.sort((a, b) => a.start - b.start || b.event.allDay - a.event.allDay);
}
function createEventContent(chunk, displayEventEnd, eventContent, theme, _intlEventTime, _view) {
  let timeText = _intlEventTime.formatRange(
    chunk.start,
    displayEventEnd && chunk.event.display !== "pointer" ? copyTime(cloneDate(chunk.start), chunk.end) : chunk.start
  );
  let content;
  if (eventContent) {
    content = is_function(eventContent) ? eventContent({
      event: toEventWithLocalDates(chunk.event),
      timeText,
      view: toViewWithLocalDates(_view)
    }) : eventContent;
  } else {
    let domNodes;
    switch (chunk.event.display) {
      case "background":
        domNodes = [];
        break;
      case "pointer":
        domNodes = [createTimeElement(timeText, chunk, theme)];
        break;
      default:
        domNodes = [
          ...chunk.event.allDay ? [] : [createTimeElement(timeText, chunk, theme)],
          createElement("h4", theme.eventTitle, chunk.event.title)
        ];
    }
    content = { domNodes };
  }
  return [timeText, content];
}
function createTimeElement(timeText, chunk, theme) {
  return createElement(
    "time",
    theme.eventTime,
    timeText,
    [["datetime", toISOString(chunk.start)]]
  );
}
function createEventClasses(eventClassNames, event, _view) {
  if (eventClassNames) {
    if (is_function(eventClassNames)) {
      eventClassNames = eventClassNames({
        event: toEventWithLocalDates(event),
        view: toViewWithLocalDates(_view)
      });
    }
    return Array.isArray(eventClassNames) ? eventClassNames : [eventClassNames];
  }
  return [];
}
function toEventWithLocalDates(event) {
  return _cloneEvent(event, toLocalDate);
}
function cloneEvent(event) {
  return _cloneEvent(event, cloneDate);
}
function _cloneEvent(event, dateFn) {
  event = assign({}, event);
  event.start = dateFn(event.start);
  event.end = dateFn(event.end);
  return event;
}
function prepareEventChunks(chunks, hiddenDays) {
  let longChunks = {};
  if (chunks.length) {
    sortEventChunks(chunks);
    let prevChunk;
    for (let chunk of chunks) {
      let dates = [];
      let date = setMidnight(cloneDate(chunk.start));
      while (chunk.end > date) {
        if (!hiddenDays.includes(date.getUTCDay())) {
          dates.push(cloneDate(date));
          if (dates.length > 1) {
            let key = date.getTime();
            if (longChunks[key]) {
              longChunks[key].chunks.push(chunk);
            } else {
              longChunks[key] = {
                sorted: false,
                chunks: [chunk]
              };
            }
          }
        }
        addDay(date);
      }
      if (dates.length) {
        chunk.date = dates[0];
        chunk.days = dates.length;
        chunk.dates = dates;
      } else {
        chunk.date = setMidnight(cloneDate(chunk.start));
        chunk.days = 1;
        chunk.dates = [chunk.date];
      }
      if (prevChunk && datesEqual(prevChunk.date, chunk.date)) {
        chunk.prev = prevChunk;
      }
      prevChunk = chunk;
    }
  }
  return longChunks;
}
function repositionEvent(chunk, longChunks, height2) {
  chunk.top = 0;
  if (chunk.prev) {
    chunk.top = chunk.prev.bottom + 1;
  }
  chunk.bottom = chunk.top + height2;
  let margin = 1;
  let key = chunk.date.getTime();
  if (longChunks[key]) {
    if (!longChunks[key].sorted) {
      longChunks[key].chunks.sort((a, b) => a.top - b.top);
      longChunks[key].sorted = true;
    }
    for (let longChunk of longChunks[key].chunks) {
      if (chunk.top < longChunk.bottom && chunk.bottom > longChunk.top) {
        let offset = longChunk.bottom - chunk.top + 1;
        margin += offset;
        chunk.top += offset;
        chunk.bottom += offset;
      }
    }
  }
  return margin;
}
function runReposition(refs, data) {
  var _a;
  refs.length = data.length;
  let result = [];
  for (let ref of refs) {
    result.push((_a = ref == null ? void 0 : ref.reposition) == null ? void 0 : _a.call(ref));
  }
  return result;
}
function eventIntersects(event, start, end, resource) {
  return event.start < end && event.end > start && (resource === void 0 || event.resourceIds.includes(resource.id));
}
function helperEvent(display) {
  return previewEvent(display) || ghostEvent(display) || pointerEvent(display);
}
function bgEvent(display) {
  return display === "background";
}
function previewEvent(display) {
  return display === "preview";
}
function ghostEvent(display) {
  return display === "ghost";
}
function pointerEvent(display) {
  return display === "pointer";
}

// node_modules/@event-calendar/core/src/lib/options.js
function btnTextDay(text2) {
  return btnText(text2, "day");
}
function btnTextWeek(text2) {
  return btnText(text2, "week");
}
function btnTextMonth(text2) {
  return btnText(text2, "month");
}
function btnTextYear(text2) {
  return btnText(text2, "year");
}
function btnText(text2, period) {
  return {
    ...text2,
    next: "Next " + period,
    prev: "Previous " + period
  };
}
function themeView(view2) {
  return (theme) => ({ ...theme, view: view2 });
}

// node_modules/@event-calendar/core/src/lib/stores.js
function intl(locale, format) {
  return derived([locale, format], ([$locale, $format]) => {
    let intl2 = is_function($format) ? { format: $format } : new Intl.DateTimeFormat($locale, $format);
    return {
      format: (date) => intl2.format(toLocalDate(date))
    };
  });
}
function intlRange(locale, format) {
  return derived([locale, format], ([$locale, $format]) => {
    let formatRange;
    if (is_function($format)) {
      formatRange = $format;
    } else {
      let intl2 = new Intl.DateTimeFormat($locale, $format);
      formatRange = (start, end) => {
        if (start <= end) {
          return intl2.formatRange(start, end);
        } else {
          let parts = intl2.formatRangeToParts(end, start);
          let result = "";
          let sources = ["startRange", "endRange"];
          let processed = [false, false];
          for (let part of parts) {
            let i = sources.indexOf(part.source);
            if (i >= 0) {
              if (!processed[i]) {
                result += _getParts(sources[1 - i], parts);
                processed[i] = true;
              }
            } else {
              result += part.value;
            }
          }
          return result;
        }
      };
    }
    return {
      formatRange: (start, end) => formatRange(toLocalDate(start), toLocalDate(end))
    };
  });
}
function _getParts(source, parts) {
  let result = "";
  for (let part of parts) {
    if (part.source == source) {
      result += part.value;
    }
  }
  return result;
}

// node_modules/@event-calendar/core/src/lib/times.js
function createTimes(date, $slotDuration, $_slotTimeLimits, $_intlSlotLabel, $_intlDayHeaderAL) {
  date = cloneDate(date);
  let compact = $slotDuration.seconds < 3600;
  let times = [];
  let end = cloneDate(date);
  let i = 1;
  addDuration(date, $_slotTimeLimits.min);
  addDuration(end, $_slotTimeLimits.max);
  while (date < end) {
    times.push([
      toISOString(date),
      $_intlSlotLabel.format(date),
      times.length && (i || !compact),
      $_intlDayHeaderAL && $_intlDayHeaderAL.format(date)
    ]);
    addDuration(date, $slotDuration);
    i = 1 - i;
  }
  return times;
}
function createSlotTimeLimits($slotMinTime, $slotMaxTime, $flexibleSlotTimeLimits, $_viewDates, $_events) {
  let min2 = createDuration($slotMinTime);
  let max2 = createDuration($slotMaxTime);
  if ($flexibleSlotTimeLimits) {
    let minMin = createDuration(min(toSeconds(min2), max(0, toSeconds(max2) - DAY_IN_SECONDS)));
    let maxMax = createDuration(max(toSeconds(max2), toSeconds(minMin) + DAY_IN_SECONDS));
    let filter = is_function($flexibleSlotTimeLimits == null ? void 0 : $flexibleSlotTimeLimits.eventFilter) ? $flexibleSlotTimeLimits.eventFilter : (event) => !bgEvent(event.display);
    loop:
      for (let date of $_viewDates) {
        let start = addDuration(cloneDate(date), min2);
        let end = addDuration(cloneDate(date), max2);
        let minStart = addDuration(cloneDate(date), minMin);
        let maxEnd = addDuration(cloneDate(date), maxMax);
        for (let event of $_events) {
          if (!event.allDay && filter(event) && event.start < maxEnd && event.end > minStart) {
            if (event.start < start) {
              let seconds = max((event.start - date) / 1e3, toSeconds(minMin));
              if (seconds < toSeconds(min2)) {
                min2.seconds = seconds;
              }
            }
            if (event.end > end) {
              let seconds = min((event.end - date) / 1e3, toSeconds(maxMax));
              if (seconds > toSeconds(max2)) {
                max2.seconds = seconds;
              }
            }
            if (toSeconds(min2) === toSeconds(minMin) && toSeconds(max2) === toSeconds(maxMax)) {
              break loop;
            }
          }
        }
      }
  }
  return { min: min2, max: max2 };
}

// node_modules/@event-calendar/core/src/storage/options.js
function createOptions(plugins) {
  var _a;
  let options = {
    allDayContent: void 0,
    allDaySlot: true,
    buttonText: {
      today: "today"
    },
    customButtons: {},
    date: /* @__PURE__ */ new Date(),
    datesSet: void 0,
    dayHeaderFormat: {
      weekday: "short",
      month: "numeric",
      day: "numeric"
    },
    dayHeaderAriaLabelFormat: {
      dateStyle: "long"
    },
    displayEventEnd: true,
    duration: { weeks: 1 },
    events: [],
    eventAllUpdated: void 0,
    eventBackgroundColor: void 0,
    eventTextColor: void 0,
    eventClassNames: void 0,
    eventClick: void 0,
    eventColor: void 0,
    eventContent: void 0,
    eventDidMount: void 0,
    eventMouseEnter: void 0,
    eventMouseLeave: void 0,
    eventSources: [],
    eventTimeFormat: {
      hour: "numeric",
      minute: "2-digit"
    },
    firstDay: 0,
    flexibleSlotTimeLimits: false,
    // ec option
    headerToolbar: {
      start: "title",
      center: "",
      end: "today prev,next"
    },
    height: void 0,
    hiddenDays: [],
    highlightedDates: [],
    // ec option
    lazyFetching: true,
    loading: void 0,
    locale: void 0,
    nowIndicator: false,
    resourceLabelContent: void 0,
    resourceLabelDidMount: void 0,
    resources: [],
    selectable: false,
    scrollTime: "06:00:00",
    slotDuration: "00:30:00",
    slotEventOverlap: true,
    slotHeight: 24,
    // ec option
    slotLabelFormat: {
      hour: "numeric",
      minute: "2-digit"
    },
    slotMaxTime: "24:00:00",
    slotMinTime: "00:00:00",
    slotWidth: 52,
    theme: {
      allDay: "ec-all-day",
      active: "ec-active",
      bgEvent: "ec-bg-event",
      bgEvents: "ec-bg-events",
      body: "ec-body",
      button: "ec-button",
      buttonGroup: "ec-button-group",
      calendar: "ec",
      compact: "ec-compact",
      content: "ec-content",
      day: "ec-day",
      dayHead: "ec-day-head",
      days: "ec-days",
      event: "ec-event",
      eventBody: "ec-event-body",
      eventTime: "ec-event-time",
      eventTitle: "ec-event-title",
      events: "ec-events",
      extra: "ec-extra",
      handle: "ec-handle",
      header: "ec-header",
      hiddenScroll: "ec-hidden-scroll",
      highlight: "ec-highlight",
      icon: "ec-icon",
      line: "ec-line",
      lines: "ec-lines",
      nowIndicator: "ec-now-indicator",
      otherMonth: "ec-other-month",
      resource: "ec-resource",
      sidebar: "ec-sidebar",
      sidebarTitle: "ec-sidebar-title",
      today: "ec-today",
      time: "ec-time",
      title: "ec-title",
      toolbar: "ec-toolbar",
      view: "",
      weekdays: ["ec-sun", "ec-mon", "ec-tue", "ec-wed", "ec-thu", "ec-fri", "ec-sat"],
      withScroll: "ec-with-scroll"
    },
    titleFormat: {
      year: "numeric",
      month: "short",
      day: "numeric"
    },
    view: void 0,
    viewDidMount: void 0,
    views: {}
  };
  for (let plugin of plugins) {
    (_a = plugin.createOptions) == null ? void 0 : _a.call(plugin, options);
  }
  return options;
}
function createParsers(plugins) {
  var _a;
  let parsers = {
    date: (date) => setMidnight(createDate(date)),
    duration: createDuration,
    events: createEvents,
    eventSources: createEventSources,
    hiddenDays: (days) => [...new Set(days)],
    highlightedDates: (dates) => dates.map(createDate),
    scrollTime: createDuration,
    slotDuration: createDuration,
    slotMaxTime: createDuration,
    slotMinTime: createDuration
  };
  for (let plugin of plugins) {
    (_a = plugin.createParsers) == null ? void 0 : _a.call(plugin, parsers);
  }
  return parsers;
}
function diff(options, prevOptions) {
  let diff2 = [];
  for (let key of keys(options)) {
    if (options[key] !== prevOptions[key]) {
      diff2.push([key, options[key]]);
    }
  }
  assign(prevOptions, options);
  return diff2;
}

// node_modules/@event-calendar/core/src/storage/stores.js
function dayGrid(state) {
  return derived(state.view, ($view) => $view == null ? void 0 : $view.startsWith("dayGrid"));
}
function activeRange(state) {
  return derived(
    [state._currentRange, state.firstDay, state.slotMaxTime, state._dayGrid],
    ([$_currentRange, $firstDay, $slotMaxTime, $_dayGrid]) => {
      let start = cloneDate($_currentRange.start);
      let end = cloneDate($_currentRange.end);
      if ($_dayGrid) {
        prevClosestDay(start, $firstDay);
        nextClosestDay(end, $firstDay);
      } else if ($slotMaxTime.days || $slotMaxTime.seconds > DAY_IN_SECONDS) {
        addDuration(subtractDay(end), $slotMaxTime);
        let start2 = subtractDay(cloneDate(end));
        if (start2 < start) {
          start = start2;
        }
      }
      return { start, end };
    }
  );
}
function currentRange(state) {
  return derived(
    [state.date, state.duration, state.firstDay, state._dayGrid],
    ([$date, $duration, $firstDay, $_dayGrid]) => {
      let start = cloneDate($date), end;
      if ($_dayGrid) {
        start.setUTCDate(1);
      } else if ($duration.inWeeks) {
        prevClosestDay(start, $firstDay);
      }
      end = addDuration(cloneDate(start), $duration);
      return { start, end };
    }
  );
}
function viewDates(state) {
  return derived([state._activeRange, state.hiddenDays], ([$_activeRange, $hiddenDays]) => {
    let dates = [];
    let date = setMidnight(cloneDate($_activeRange.start));
    let end = setMidnight(cloneDate($_activeRange.end));
    while (date < end) {
      if (!$hiddenDays.includes(date.getUTCDay())) {
        dates.push(cloneDate(date));
      }
      addDay(date);
    }
    if (!dates.length && $hiddenDays.length && $hiddenDays.length < 7) {
      state.date.update((date2) => {
        while ($hiddenDays.includes(date2.getUTCDay())) {
          addDay(date2);
        }
        return date2;
      });
      dates = get_store_value(state._viewDates);
    }
    return dates;
  });
}
function viewTitle(state) {
  return derived(
    [state.date, state._activeRange, state._intlTitle, state._dayGrid],
    ([$date, $_activeRange, $_intlTitle, $_dayGrid]) => {
      return $_dayGrid ? $_intlTitle.formatRange($date, $date) : $_intlTitle.formatRange($_activeRange.start, subtractDay(cloneDate($_activeRange.end)));
    }
  );
}
function view(state) {
  return derived([state.view, state._viewTitle, state._currentRange, state._activeRange], (args) => createView(...args));
}
function events(state) {
  let _events = writable([]);
  let abortController;
  let fetching = 0;
  let debounceHandle = {};
  derived(
    [state.events, state.eventSources, state._activeRange, state._fetchedRange, state.lazyFetching, state.loading],
    (values, set) => debounce(() => {
      let [$events, $eventSources, $_activeRange, $_fetchedRange, $lazyFetching, $loading] = values;
      if (!$eventSources.length) {
        set($events);
        return;
      }
      if (!$_fetchedRange.start || $_fetchedRange.start > $_activeRange.start || $_fetchedRange.end < $_activeRange.end || !$lazyFetching) {
        if (abortController) {
          abortController.abort();
        }
        abortController = new AbortController();
        if (is_function($loading) && !fetching) {
          $loading(true);
        }
        let stopLoading = () => {
          if (--fetching === 0 && is_function($loading)) {
            $loading(false);
          }
        };
        let events2 = [];
        let failure = (e) => stopLoading();
        let success = (data) => {
          events2 = events2.concat(createEvents(data));
          set(events2);
          stopLoading();
        };
        let startStr = toISOString($_activeRange.start);
        let endStr = toISOString($_activeRange.end);
        for (let source of $eventSources) {
          if (is_function(source.events)) {
            let result = source.events({
              start: toLocalDate($_activeRange.start),
              end: toLocalDate($_activeRange.end),
              startStr,
              endStr
            }, success, failure);
            if (result !== void 0) {
              Promise.resolve(result).then(success, failure);
            }
          } else {
            let params = is_function(source.extraParams) ? source.extraParams() : assign({}, source.extraParams);
            params.start = startStr;
            params.end = endStr;
            params = new URLSearchParams(params);
            let url = source.url, headers = {}, body;
            if (["GET", "HEAD"].includes(source.method)) {
              url += (url.includes("?") ? "&" : "?") + params;
            } else {
              headers["content-type"] = "application/x-www-form-urlencoded;charset=UTF-8";
              body = String(params);
            }
            fetch(url, { method: source.method, headers, body, signal: abortController.signal, credentials: "same-origin" }).then((response) => response.json()).then(success).catch(failure);
          }
          ++fetching;
        }
        $_fetchedRange.start = $_activeRange.start;
        $_fetchedRange.end = $_activeRange.end;
      }
    }, debounceHandle, state._queue),
    []
  ).subscribe(_events.set);
  return _events;
}
function now() {
  return readable(createDate(), (set) => {
    let interval = setInterval(() => {
      set(createDate());
    }, 1e3);
    return () => clearInterval(interval);
  });
}
function today(state) {
  return derived(state._now, ($_now) => setMidnight(cloneDate($_now)));
}

// node_modules/@event-calendar/core/src/storage/state.js
var state_default = class {
  constructor(plugins, input) {
    var _a, _b;
    plugins = plugins || [];
    let options = createOptions(plugins);
    let parsers = createParsers(plugins);
    options = parseOpts(options, parsers);
    input = parseOpts(input, parsers);
    for (let [option, value] of Object.entries(options)) {
      this[option] = writable(value);
    }
    this._queue = writable(/* @__PURE__ */ new Map());
    this._queue2 = writable(/* @__PURE__ */ new Map());
    this._tasks = /* @__PURE__ */ new Map();
    this._auxiliary = writable([]);
    this._dayGrid = dayGrid(this);
    this._currentRange = currentRange(this);
    this._activeRange = activeRange(this);
    this._fetchedRange = writable({ start: void 0, end: void 0 });
    this._events = events(this);
    this._now = now();
    this._today = today(this);
    this._intlEventTime = intlRange(this.locale, this.eventTimeFormat);
    this._intlSlotLabel = intl(this.locale, this.slotLabelFormat);
    this._intlDayHeader = intl(this.locale, this.dayHeaderFormat);
    this._intlDayHeaderAL = intl(this.locale, this.dayHeaderAriaLabelFormat);
    this._intlTitle = intlRange(this.locale, this.titleFormat);
    this._bodyEl = writable(void 0);
    this._scrollable = writable(false);
    this._viewTitle = viewTitle(this);
    this._viewDates = viewDates(this);
    this._view = view(this);
    this._viewComponent = writable(void 0);
    this._resBgColor = writable(noop);
    this._resTxtColor = writable(noop);
    this._interaction = writable({});
    this._iEvents = writable([null, null]);
    this._iClasses = writable(identity);
    this._iClass = writable(void 0);
    this._set = (key, value) => {
      if (validKey(key, this)) {
        if (parsers[key]) {
          value = parsers[key](value);
        }
        this[key].set(value);
      }
    };
    this._get = (key) => validKey(key, this) ? get_store_value(this[key]) : void 0;
    for (let plugin of plugins) {
      (_a = plugin.createStores) == null ? void 0 : _a.call(plugin, this);
    }
    if (input.view) {
      this.view.set(input.view);
    }
    let views = /* @__PURE__ */ new Set([...keys(options.views), ...keys(input.views ?? {})]);
    for (let view2 of views) {
      let defOpts = mergeOpts(options, options.views[view2] ?? {});
      let opts = mergeOpts(defOpts, input, ((_b = input.views) == null ? void 0 : _b[view2]) ?? {});
      let component = opts.component;
      filterOpts(opts, this);
      for (let key of keys(opts)) {
        let { set, _set = set, ...rest } = this[key];
        this[key] = {
          // Set value in all views
          set: ["buttonText", "theme"].includes(key) ? (value) => {
            if (is_function(value)) {
              let result = value(defOpts[key]);
              opts[key] = result;
              set(set === _set ? result : value);
            } else {
              opts[key] = value;
              set(value);
            }
          } : (value) => {
            opts[key] = value;
            set(value);
          },
          _set,
          ...rest
        };
      }
      this.view.subscribe((newView) => {
        if (newView === view2) {
          this._viewComponent.set(component);
          if (is_function(opts.viewDidMount)) {
            tick().then(() => opts.viewDidMount(get_store_value(this._view)));
          }
          for (let key of keys(opts)) {
            this[key]._set(opts[key]);
          }
        }
      });
    }
  }
};
function parseOpts(opts, parsers) {
  let result = { ...opts };
  for (let key of keys(parsers)) {
    if (key in result) {
      result[key] = parsers[key](result[key]);
    }
  }
  if (opts.views) {
    result.views = {};
    for (let view2 of keys(opts.views)) {
      result.views[view2] = parseOpts(opts.views[view2], parsers);
    }
  }
  return result;
}
function mergeOpts(...args) {
  let result = {};
  for (let opts of args) {
    let override = {};
    for (let key of ["buttonText", "theme"]) {
      if (is_function(opts[key])) {
        override[key] = opts[key](result[key]);
      }
    }
    result = {
      ...result,
      ...opts,
      ...override
    };
  }
  return result;
}
function filterOpts(opts, state) {
  keys(opts).filter((key) => !validKey(key, state) || key == "view").forEach((key) => delete opts[key]);
}
function validKey(key, state) {
  return state.hasOwnProperty(key) && key[0] !== "_";
}

// node_modules/@event-calendar/core/src/Buttons.svelte
var file = "node_modules/@event-calendar/core/src/Buttons.svelte";
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[25] = list[i];
  return child_ctx;
}
function create_if_block_5(ctx) {
  let button_1;
  let t_value = (
    /*$buttonText*/
    ctx[5][
      /*button*/
      ctx[25]
    ] + ""
  );
  let t;
  let button_1_class_value;
  let mounted;
  let dispose;
  function click_handler_1() {
    return (
      /*click_handler_1*/
      ctx[22](
        /*button*/
        ctx[25]
      )
    );
  }
  const block = {
    c: function create() {
      button_1 = element("button");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      button_1 = claim_element(nodes, "BUTTON", { class: true });
      var button_1_nodes = children(button_1);
      t = claim_text(button_1_nodes, t_value);
      button_1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(button_1, "class", button_1_class_value = /*$theme*/
      ctx[3].button + /*$view*/
      (ctx[7] === /*button*/
      ctx[25] ? " " + /*$theme*/
      ctx[3].active : "") + " ec-" + /*button*/
      ctx[25]);
      add_location(button_1, file, 57, 8, 1985);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button_1, anchor);
      append_hydration_dev(button_1, t);
      if (!mounted) {
        dispose = listen_dev(button_1, "click", click_handler_1, false, false, false, false);
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*$buttonText, buttons*/
      33 && t_value !== (t_value = /*$buttonText*/
      ctx[5][
        /*button*/
        ctx[25]
      ] + ""))
        set_data_dev(t, t_value);
      if (dirty & /*$theme, $view, buttons*/
      137 && button_1_class_value !== (button_1_class_value = /*$theme*/
      ctx[3].button + /*$view*/
      (ctx[7] === /*button*/
      ctx[25] ? " " + /*$theme*/
      ctx[3].active : "") + " ec-" + /*button*/
      ctx[25])) {
        attr_dev(button_1, "class", button_1_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(button_1);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_5.name,
    type: "if",
    source: "(57:27) ",
    ctx
  });
  return block;
}
function create_if_block_4(ctx) {
  let button_1;
  let t_value = (
    /*$customButtons*/
    ctx[6][
      /*button*/
      ctx[25]
    ].text + ""
  );
  let t;
  let button_1_class_value;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      button_1 = element("button");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      button_1 = claim_element(nodes, "BUTTON", { class: true });
      var button_1_nodes = children(button_1);
      t = claim_text(button_1_nodes, t_value);
      button_1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(button_1, "class", button_1_class_value = /*$theme*/
      ctx[3].button + " ec-" + /*button*/
      ctx[25]);
      add_location(button_1, file, 52, 8, 1793);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button_1, anchor);
      append_hydration_dev(button_1, t);
      if (!mounted) {
        dispose = listen_dev(
          button_1,
          "click",
          function() {
            if (is_function(
              /*$customButtons*/
              ctx[6][
                /*button*/
                ctx[25]
              ].click
            ))
              ctx[6][
                /*button*/
                ctx[25]
              ].click.apply(this, arguments);
          },
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*$customButtons, buttons*/
      65 && t_value !== (t_value = /*$customButtons*/
      ctx[6][
        /*button*/
        ctx[25]
      ].text + ""))
        set_data_dev(t, t_value);
      if (dirty & /*$theme, buttons*/
      9 && button_1_class_value !== (button_1_class_value = /*$theme*/
      ctx[3].button + " ec-" + /*button*/
      ctx[25])) {
        attr_dev(button_1, "class", button_1_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(button_1);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_4.name,
    type: "if",
    source: "(52:37) ",
    ctx
  });
  return block;
}
function create_if_block_3(ctx) {
  let button_1;
  let t_value = (
    /*$buttonText*/
    ctx[5][
      /*button*/
      ctx[25]
    ] + ""
  );
  let t;
  let button_1_class_value;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      button_1 = element("button");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      button_1 = claim_element(nodes, "BUTTON", { class: true });
      var button_1_nodes = children(button_1);
      t = claim_text(button_1_nodes, t_value);
      button_1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(button_1, "class", button_1_class_value = /*$theme*/
      ctx[3].button + " ec-" + /*button*/
      ctx[25]);
      button_1.disabled = /*isToday*/
      ctx[1];
      add_location(button_1, file, 46, 8, 1566);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button_1, anchor);
      append_hydration_dev(button_1, t);
      if (!mounted) {
        dispose = listen_dev(
          button_1,
          "click",
          /*click_handler*/
          ctx[21],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*$buttonText, buttons*/
      33 && t_value !== (t_value = /*$buttonText*/
      ctx2[5][
        /*button*/
        ctx2[25]
      ] + ""))
        set_data_dev(t, t_value);
      if (dirty & /*$theme, buttons*/
      9 && button_1_class_value !== (button_1_class_value = /*$theme*/
      ctx2[3].button + " ec-" + /*button*/
      ctx2[25])) {
        attr_dev(button_1, "class", button_1_class_value);
      }
      if (dirty & /*isToday*/
      2) {
        prop_dev(
          button_1,
          "disabled",
          /*isToday*/
          ctx2[1]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(button_1);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_3.name,
    type: "if",
    source: "(46:32) ",
    ctx
  });
  return block;
}
function create_if_block_2(ctx) {
  let button_1;
  let i;
  let i_class_value;
  let button_1_class_value;
  let button_1_aria_label_value;
  let button_1_title_value;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      button_1 = element("button");
      i = element("i");
      this.h();
    },
    l: function claim(nodes) {
      button_1 = claim_element(nodes, "BUTTON", {
        class: true,
        "aria-label": true,
        title: true
      });
      var button_1_nodes = children(button_1);
      i = claim_element(button_1_nodes, "I", { class: true });
      children(i).forEach(detach_dev);
      button_1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(i, "class", i_class_value = /*$theme*/
      ctx[3].icon + " ec-" + /*button*/
      ctx[25]);
      add_location(i, file, 44, 9, 1474);
      attr_dev(button_1, "class", button_1_class_value = /*$theme*/
      ctx[3].button + " ec-" + /*button*/
      ctx[25]);
      attr_dev(button_1, "aria-label", button_1_aria_label_value = /*$buttonText*/
      ctx[5].next);
      attr_dev(button_1, "title", button_1_title_value = /*$buttonText*/
      ctx[5].next);
      add_location(button_1, file, 39, 8, 1302);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button_1, anchor);
      append_hydration_dev(button_1, i);
      if (!mounted) {
        dispose = listen_dev(
          button_1,
          "click",
          /*next*/
          ctx[19],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*$theme, buttons*/
      9 && i_class_value !== (i_class_value = /*$theme*/
      ctx2[3].icon + " ec-" + /*button*/
      ctx2[25])) {
        attr_dev(i, "class", i_class_value);
      }
      if (dirty & /*$theme, buttons*/
      9 && button_1_class_value !== (button_1_class_value = /*$theme*/
      ctx2[3].button + " ec-" + /*button*/
      ctx2[25])) {
        attr_dev(button_1, "class", button_1_class_value);
      }
      if (dirty & /*$buttonText*/
      32 && button_1_aria_label_value !== (button_1_aria_label_value = /*$buttonText*/
      ctx2[5].next)) {
        attr_dev(button_1, "aria-label", button_1_aria_label_value);
      }
      if (dirty & /*$buttonText*/
      32 && button_1_title_value !== (button_1_title_value = /*$buttonText*/
      ctx2[5].next)) {
        attr_dev(button_1, "title", button_1_title_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(button_1);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_2.name,
    type: "if",
    source: "(39:31) ",
    ctx
  });
  return block;
}
function create_if_block_1(ctx) {
  let button_1;
  let i;
  let i_class_value;
  let button_1_class_value;
  let button_1_aria_label_value;
  let button_1_title_value;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      button_1 = element("button");
      i = element("i");
      this.h();
    },
    l: function claim(nodes) {
      button_1 = claim_element(nodes, "BUTTON", {
        class: true,
        "aria-label": true,
        title: true
      });
      var button_1_nodes = children(button_1);
      i = claim_element(button_1_nodes, "I", { class: true });
      children(i).forEach(detach_dev);
      button_1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(i, "class", i_class_value = /*$theme*/
      ctx[3].icon + " ec-" + /*button*/
      ctx[25]);
      add_location(i, file, 37, 9, 1211);
      attr_dev(button_1, "class", button_1_class_value = /*$theme*/
      ctx[3].button + " ec-" + /*button*/
      ctx[25]);
      attr_dev(button_1, "aria-label", button_1_aria_label_value = /*$buttonText*/
      ctx[5].prev);
      attr_dev(button_1, "title", button_1_title_value = /*$buttonText*/
      ctx[5].prev);
      add_location(button_1, file, 32, 8, 1039);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button_1, anchor);
      append_hydration_dev(button_1, i);
      if (!mounted) {
        dispose = listen_dev(
          button_1,
          "click",
          /*prev*/
          ctx[18],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*$theme, buttons*/
      9 && i_class_value !== (i_class_value = /*$theme*/
      ctx2[3].icon + " ec-" + /*button*/
      ctx2[25])) {
        attr_dev(i, "class", i_class_value);
      }
      if (dirty & /*$theme, buttons*/
      9 && button_1_class_value !== (button_1_class_value = /*$theme*/
      ctx2[3].button + " ec-" + /*button*/
      ctx2[25])) {
        attr_dev(button_1, "class", button_1_class_value);
      }
      if (dirty & /*$buttonText*/
      32 && button_1_aria_label_value !== (button_1_aria_label_value = /*$buttonText*/
      ctx2[5].prev)) {
        attr_dev(button_1, "aria-label", button_1_aria_label_value);
      }
      if (dirty & /*$buttonText*/
      32 && button_1_title_value !== (button_1_title_value = /*$buttonText*/
      ctx2[5].prev)) {
        attr_dev(button_1, "title", button_1_title_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(button_1);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: "(32:31) ",
    ctx
  });
  return block;
}
function create_if_block(ctx) {
  let h2;
  let h2_class_value;
  let setContent_action;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      h2 = element("h2");
      this.h();
    },
    l: function claim(nodes) {
      h2 = claim_element(nodes, "H2", { class: true });
      children(h2).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(h2, "class", h2_class_value = /*$theme*/
      ctx[3].title);
      add_location(h2, file, 30, 8, 937);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, h2, anchor);
      if (!mounted) {
        dispose = action_destroyer(setContent_action = setContent.call(
          null,
          h2,
          /*$_viewTitle*/
          ctx[4]
        ));
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*$theme*/
      8 && h2_class_value !== (h2_class_value = /*$theme*/
      ctx2[3].title)) {
        attr_dev(h2, "class", h2_class_value);
      }
      if (setContent_action && is_function(setContent_action.update) && dirty & /*$_viewTitle*/
      16)
        setContent_action.update.call(
          null,
          /*$_viewTitle*/
          ctx2[4]
        );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(h2);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(29:4) {#if button == 'title'}",
    ctx
  });
  return block;
}
function create_each_block(ctx) {
  let if_block_anchor;
  function select_block_type(ctx2, dirty) {
    if (
      /*button*/
      ctx2[25] == "title"
    )
      return create_if_block;
    if (
      /*button*/
      ctx2[25] == "prev"
    )
      return create_if_block_1;
    if (
      /*button*/
      ctx2[25] == "next"
    )
      return create_if_block_2;
    if (
      /*button*/
      ctx2[25] == "today"
    )
      return create_if_block_3;
    if (
      /*$customButtons*/
      ctx2[6][
        /*button*/
        ctx2[25]
      ]
    )
      return create_if_block_4;
    if (
      /*button*/
      ctx2[25] != ""
    )
      return create_if_block_5;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block = current_block_type && current_block_type(ctx);
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if (if_block)
          if_block.d(1);
        if_block = current_block_type && current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block) {
        if_block.d(detaching);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block.name,
    type: "each",
    source: "(28:0) {#each buttons as button}",
    ctx
  });
  return block;
}
function create_fragment(ctx) {
  let each_1_anchor;
  let each_value = ensure_array_like_dev(
    /*buttons*/
    ctx[0]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*$theme, $_viewTitle, buttons, $buttonText, prev, next, isToday, $date, today, $customButtons, $view*/
      917759) {
        each_value = ensure_array_like_dev(
          /*buttons*/
          ctx2[0]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let $duration;
  let $date;
  let $hiddenDays;
  let $_currentRange;
  let $theme;
  let $_viewTitle;
  let $buttonText;
  let $customButtons;
  let $view;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Buttons", slots, []);
  let { buttons } = $$props;
  let { _currentRange, _viewTitle, buttonText, customButtons, date, duration, hiddenDays, theme, view: view2 } = getContext("state");
  validate_store(_currentRange, "_currentRange");
  component_subscribe($$self, _currentRange, (value) => $$invalidate(20, $_currentRange = value));
  validate_store(_viewTitle, "_viewTitle");
  component_subscribe($$self, _viewTitle, (value) => $$invalidate(4, $_viewTitle = value));
  validate_store(buttonText, "buttonText");
  component_subscribe($$self, buttonText, (value) => $$invalidate(5, $buttonText = value));
  validate_store(customButtons, "customButtons");
  component_subscribe($$self, customButtons, (value) => $$invalidate(6, $customButtons = value));
  validate_store(date, "date");
  component_subscribe($$self, date, (value) => $$invalidate(2, $date = value));
  validate_store(duration, "duration");
  component_subscribe($$self, duration, (value) => $$invalidate(23, $duration = value));
  validate_store(hiddenDays, "hiddenDays");
  component_subscribe($$self, hiddenDays, (value) => $$invalidate(24, $hiddenDays = value));
  validate_store(theme, "theme");
  component_subscribe($$self, theme, (value) => $$invalidate(3, $theme = value));
  validate_store(view2, "view");
  component_subscribe($$self, view2, (value) => $$invalidate(7, $view = value));
  let today2 = setMidnight(createDate()), isToday;
  function prev() {
    let d = subtractDuration($date, $duration);
    if ($hiddenDays.length && $hiddenDays.length < 7) {
      while ($hiddenDays.includes(d.getUTCDay())) {
        subtractDay(d);
      }
    }
    set_store_value(date, $date = d, $date);
  }
  function next() {
    set_store_value(date, $date = addDuration($date, $duration), $date);
  }
  $$self.$$.on_mount.push(function() {
    if (buttons === void 0 && !("buttons" in $$props || $$self.$$.bound[$$self.$$.props["buttons"]])) {
      console.warn("<Buttons> was created without expected prop 'buttons'");
    }
  });
  const writable_props = ["buttons"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Buttons> was created with unknown prop '${key}'`);
  });
  const click_handler = () => set_store_value(date, $date = cloneDate(today2), $date);
  const click_handler_1 = (button) => set_store_value(view2, $view = button, $view);
  $$self.$$set = ($$props2) => {
    if ("buttons" in $$props2)
      $$invalidate(0, buttons = $$props2.buttons);
  };
  $$self.$capture_state = () => ({
    getContext,
    createDate,
    cloneDate,
    subtractDay,
    addDuration,
    setContent,
    subtractDuration,
    setMidnight,
    buttons,
    _currentRange,
    _viewTitle,
    buttonText,
    customButtons,
    date,
    duration,
    hiddenDays,
    theme,
    view: view2,
    today: today2,
    isToday,
    prev,
    next,
    $duration,
    $date,
    $hiddenDays,
    $_currentRange,
    $theme,
    $_viewTitle,
    $buttonText,
    $customButtons,
    $view
  });
  $$self.$inject_state = ($$props2) => {
    if ("buttons" in $$props2)
      $$invalidate(0, buttons = $$props2.buttons);
    if ("_currentRange" in $$props2)
      $$invalidate(8, _currentRange = $$props2._currentRange);
    if ("_viewTitle" in $$props2)
      $$invalidate(9, _viewTitle = $$props2._viewTitle);
    if ("buttonText" in $$props2)
      $$invalidate(10, buttonText = $$props2.buttonText);
    if ("customButtons" in $$props2)
      $$invalidate(11, customButtons = $$props2.customButtons);
    if ("date" in $$props2)
      $$invalidate(12, date = $$props2.date);
    if ("duration" in $$props2)
      $$invalidate(13, duration = $$props2.duration);
    if ("hiddenDays" in $$props2)
      $$invalidate(14, hiddenDays = $$props2.hiddenDays);
    if ("theme" in $$props2)
      $$invalidate(15, theme = $$props2.theme);
    if ("view" in $$props2)
      $$invalidate(16, view2 = $$props2.view);
    if ("today" in $$props2)
      $$invalidate(17, today2 = $$props2.today);
    if ("isToday" in $$props2)
      $$invalidate(1, isToday = $$props2.isToday);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$_currentRange*/
    1048576) {
      $:
        $$invalidate(1, isToday = today2 >= $_currentRange.start && today2 < $_currentRange.end || null);
    }
  };
  return [
    buttons,
    isToday,
    $date,
    $theme,
    $_viewTitle,
    $buttonText,
    $customButtons,
    $view,
    _currentRange,
    _viewTitle,
    buttonText,
    customButtons,
    date,
    duration,
    hiddenDays,
    theme,
    view2,
    today2,
    prev,
    next,
    $_currentRange,
    click_handler,
    click_handler_1
  ];
}
var Buttons = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, { buttons: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Buttons",
      options,
      id: create_fragment.name
    });
  }
  get buttons() {
    throw new Error("<Buttons>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttons(value) {
    throw new Error("<Buttons>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Buttons_default = Buttons;

// node_modules/@event-calendar/core/src/Toolbar.svelte
var { Object: Object_1 } = globals;
var file2 = "node_modules/@event-calendar/core/src/Toolbar.svelte";
function get_each_context2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[5] = list[i];
  return child_ctx;
}
function get_each_context_1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[8] = list[i];
  return child_ctx;
}
function create_else_block(ctx) {
  let buttons_1;
  let current;
  buttons_1 = new Buttons_default({
    props: { buttons: (
      /*buttons*/
      ctx[8]
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(buttons_1.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(buttons_1.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(buttons_1, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const buttons_1_changes = {};
      if (dirty & /*sections*/
      1)
        buttons_1_changes.buttons = /*buttons*/
        ctx2[8];
      buttons_1.$set(buttons_1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(buttons_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(buttons_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(buttons_1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block.name,
    type: "else",
    source: "(28:16) {:else}",
    ctx
  });
  return block;
}
function create_if_block2(ctx) {
  let div;
  let buttons_1;
  let div_class_value;
  let current;
  buttons_1 = new Buttons_default({
    props: { buttons: (
      /*buttons*/
      ctx[8]
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      div = element("div");
      create_component(buttons_1.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      claim_component(buttons_1.$$.fragment, div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = /*$theme*/
      ctx[1].buttonGroup);
      add_location(div, file2, 24, 20, 600);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      mount_component(buttons_1, div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const buttons_1_changes = {};
      if (dirty & /*sections*/
      1)
        buttons_1_changes.buttons = /*buttons*/
        ctx2[8];
      buttons_1.$set(buttons_1_changes);
      if (!current || dirty & /*$theme*/
      2 && div_class_value !== (div_class_value = /*$theme*/
      ctx2[1].buttonGroup)) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(buttons_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(buttons_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      destroy_component(buttons_1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block2.name,
    type: "if",
    source: "(24:16) {#if buttons.length > 1}",
    ctx
  });
  return block;
}
function create_each_block_1(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block2, create_else_block];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*buttons*/
      ctx2[8].length > 1
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_1.name,
    type: "each",
    source: "(23:12) {#each sections[key] as buttons}",
    ctx
  });
  return block;
}
function create_each_block2(ctx) {
  let div;
  let t;
  let current;
  let each_value_1 = ensure_array_like_dev(
    /*sections*/
    ctx[0][
      /*key*/
      ctx[5]
    ]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t = space();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(div_nodes);
      }
      t = claim_space(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(div, file2, 21, 8, 488);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
      append_hydration_dev(div, t);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*$theme, sections, Object*/
      3) {
        each_value_1 = ensure_array_like_dev(
          /*sections*/
          ctx2[0][
            /*key*/
            ctx2[5]
          ]
        );
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_1(ctx2, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block_1(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div, t);
          }
        }
        group_outros();
        for (i = each_value_1.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value_1.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block2.name,
    type: "each",
    source: "(21:4) {#each Object.keys(sections) as key}",
    ctx
  });
  return block;
}
function create_fragment2(ctx) {
  let nav;
  let nav_class_value;
  let current;
  let each_value = ensure_array_like_dev(Object.keys(
    /*sections*/
    ctx[0]
  ));
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block2(get_each_context2(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      nav = element("nav");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      nav = claim_element(nodes, "NAV", { class: true });
      var nav_nodes = children(nav);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nav_nodes);
      }
      nav_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(nav, "class", nav_class_value = /*$theme*/
      ctx[1].toolbar);
      add_location(nav, file2, 19, 0, 408);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, nav, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(nav, null);
        }
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*sections, Object, $theme*/
      3) {
        each_value = ensure_array_like_dev(Object.keys(
          /*sections*/
          ctx2[0]
        ));
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context2(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block2(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(nav, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
      if (!current || dirty & /*$theme*/
      2 && nav_class_value !== (nav_class_value = /*$theme*/
      ctx2[1].toolbar)) {
        attr_dev(nav, "class", nav_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(nav);
      }
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance2($$self, $$props, $$invalidate) {
  let $headerToolbar;
  let $theme;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Toolbar", slots, []);
  let { headerToolbar, theme } = getContext("state");
  validate_store(headerToolbar, "headerToolbar");
  component_subscribe($$self, headerToolbar, (value) => $$invalidate(4, $headerToolbar = value));
  validate_store(theme, "theme");
  component_subscribe($$self, theme, (value) => $$invalidate(1, $theme = value));
  let sections = { start: [], center: [], end: [] };
  const writable_props = [];
  Object_1.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Toolbar> was created with unknown prop '${key}'`);
  });
  $$self.$capture_state = () => ({
    getContext,
    Buttons: Buttons_default,
    headerToolbar,
    theme,
    sections,
    $headerToolbar,
    $theme
  });
  $$self.$inject_state = ($$props2) => {
    if ("headerToolbar" in $$props2)
      $$invalidate(2, headerToolbar = $$props2.headerToolbar);
    if ("theme" in $$props2)
      $$invalidate(3, theme = $$props2.theme);
    if ("sections" in $$props2)
      $$invalidate(0, sections = $$props2.sections);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*sections, $headerToolbar*/
    17) {
      $: {
        for (let key of Object.keys(sections)) {
          $$invalidate(0, sections[key] = $headerToolbar[key].split(" ").map((group) => group.split(",")), sections);
        }
      }
    }
  };
  return [sections, $theme, headerToolbar, theme, $headerToolbar];
}
var Toolbar = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance2, create_fragment2, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Toolbar",
      options,
      id: create_fragment2.name
    });
  }
};
var Toolbar_default = Toolbar;

// node_modules/@event-calendar/core/src/Auxiliary.svelte
function get_each_context3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[11] = list[i];
  return child_ctx;
}
function create_each_block3(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = (
    /*component*/
    ctx[11]
  );
  function switch_props(ctx2, dirty) {
    return { $$inline: true };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance)
        claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*$_auxiliary*/
      1 && switch_value !== (switch_value = /*component*/
      ctx2[11])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(switch_instance_anchor);
      }
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block3.name,
    type: "each",
    source: "(25:0) {#each $_auxiliary as component}",
    ctx
  });
  return block;
}
function create_fragment3(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like_dev(
    /*$_auxiliary*/
    ctx[0]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block3(get_each_context3(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*$_auxiliary*/
      1) {
        each_value = ensure_array_like_dev(
          /*$_auxiliary*/
          ctx2[0]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context3(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block3(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance3($$self, $$props, $$invalidate) {
  let $_view;
  let $datesSet;
  let $_activeRange;
  let $_auxiliary;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Auxiliary", slots, []);
  let { datesSet, _auxiliary, _activeRange, _queue, _view } = getContext("state");
  validate_store(datesSet, "datesSet");
  component_subscribe($$self, datesSet, (value) => $$invalidate(7, $datesSet = value));
  validate_store(_auxiliary, "_auxiliary");
  component_subscribe($$self, _auxiliary, (value) => $$invalidate(0, $_auxiliary = value));
  validate_store(_activeRange, "_activeRange");
  component_subscribe($$self, _activeRange, (value) => $$invalidate(5, $_activeRange = value));
  validate_store(_view, "_view");
  component_subscribe($$self, _view, (value) => $$invalidate(6, $_view = value));
  let debounceHandle = {};
  function runDatesSet(_activeRange2) {
    if (is_function($datesSet)) {
      debounce(
        () => $datesSet({
          start: toLocalDate(_activeRange2.start),
          end: toLocalDate(_activeRange2.end),
          startStr: toISOString(_activeRange2.start),
          endStr: toISOString(_activeRange2.end),
          view: toViewWithLocalDates($_view)
        }),
        debounceHandle,
        _queue
      );
    }
  }
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Auxiliary> was created with unknown prop '${key}'`);
  });
  $$self.$capture_state = () => ({
    getContext,
    is_function,
    debounce,
    toISOString,
    toLocalDate,
    toViewWithLocalDates,
    datesSet,
    _auxiliary,
    _activeRange,
    _queue,
    _view,
    debounceHandle,
    runDatesSet,
    $_view,
    $datesSet,
    $_activeRange,
    $_auxiliary
  });
  $$self.$inject_state = ($$props2) => {
    if ("datesSet" in $$props2)
      $$invalidate(1, datesSet = $$props2.datesSet);
    if ("_auxiliary" in $$props2)
      $$invalidate(2, _auxiliary = $$props2._auxiliary);
    if ("_activeRange" in $$props2)
      $$invalidate(3, _activeRange = $$props2._activeRange);
    if ("_queue" in $$props2)
      _queue = $$props2._queue;
    if ("_view" in $$props2)
      $$invalidate(4, _view = $$props2._view);
    if ("debounceHandle" in $$props2)
      debounceHandle = $$props2.debounceHandle;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$_activeRange*/
    32) {
      $:
        runDatesSet($_activeRange);
    }
  };
  return [$_auxiliary, datesSet, _auxiliary, _activeRange, _view, $_activeRange];
}
var Auxiliary = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance3, create_fragment3, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Auxiliary",
      options,
      id: create_fragment3.name
    });
  }
};
var Auxiliary_default = Auxiliary;

// node_modules/@event-calendar/core/src/Calendar.svelte
var file3 = "node_modules/@event-calendar/core/src/Calendar.svelte";
function create_fragment4(ctx) {
  let div;
  let toolbar;
  let t0;
  let switch_instance;
  let div_class_value;
  let div_role_value;
  let t1;
  let auxiliary;
  let current;
  let mounted;
  let dispose;
  toolbar = new Toolbar_default({ $$inline: true });
  var switch_value = (
    /*$_viewComponent*/
    ctx[5]
  );
  function switch_props(ctx2, dirty) {
    return { $$inline: true };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  auxiliary = new Auxiliary_default({ $$inline: true });
  const block = {
    c: function create() {
      div = element("div");
      create_component(toolbar.$$.fragment);
      t0 = space();
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      t1 = space();
      create_component(auxiliary.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true, role: true });
      var div_nodes = children(div);
      claim_component(toolbar.$$.fragment, div_nodes);
      t0 = claim_space(div_nodes);
      if (switch_instance)
        claim_component(switch_instance.$$.fragment, div_nodes);
      div_nodes.forEach(detach_dev);
      t1 = claim_space(nodes);
      claim_component(auxiliary.$$.fragment, nodes);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = /*$theme*/
      ctx[1].calendar + " " + /*$theme*/
      ctx[1].view + /*$_scrollable*/
      (ctx[0] ? " " + /*$theme*/
      ctx[1].withScroll : "") + /*$_iClass*/
      (ctx[2] ? " " + /*$theme*/
      ctx[1][
        /*$_iClass*/
        ctx[2]
      ] : ""));
      attr_dev(div, "role", div_role_value = listView(
        /*$view*/
        ctx[4]
      ) ? "list" : "table");
      set_style(
        div,
        "height",
        /*$height*/
        ctx[3]
      );
      add_location(div, file3, 129, 0, 3335);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      mount_component(toolbar, div, null);
      append_hydration_dev(div, t0);
      if (switch_instance)
        mount_component(switch_instance, div, null);
      insert_hydration_dev(target, t1, anchor);
      mount_component(auxiliary, target, anchor);
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          window,
          "resize",
          /*recheckScrollable*/
          ctx[17],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*$_viewComponent*/
      32 && switch_value !== (switch_value = /*$_viewComponent*/
      ctx2[5])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, div, null);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
      }
      if (!current || dirty[0] & /*$theme, $_scrollable, $_iClass*/
      7 && div_class_value !== (div_class_value = /*$theme*/
      ctx2[1].calendar + " " + /*$theme*/
      ctx2[1].view + /*$_scrollable*/
      (ctx2[0] ? " " + /*$theme*/
      ctx2[1].withScroll : "") + /*$_iClass*/
      (ctx2[2] ? " " + /*$theme*/
      ctx2[1][
        /*$_iClass*/
        ctx2[2]
      ] : ""))) {
        attr_dev(div, "class", div_class_value);
      }
      if (!current || dirty[0] & /*$view*/
      16 && div_role_value !== (div_role_value = listView(
        /*$view*/
        ctx2[4]
      ) ? "list" : "table")) {
        attr_dev(div, "role", div_role_value);
      }
      if (dirty[0] & /*$height*/
      8) {
        set_style(
          div,
          "height",
          /*$height*/
          ctx2[3]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(toolbar.$$.fragment, local);
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      transition_in(auxiliary.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(toolbar.$$.fragment, local);
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      transition_out(auxiliary.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
        detach_dev(t1);
      }
      destroy_component(toolbar);
      if (switch_instance)
        destroy_component(switch_instance);
      destroy_component(auxiliary, detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment4.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance4($$self, $$props, $$invalidate) {
  let $_bodyEl;
  let $_scrollable;
  let $_queue2;
  let $_queue;
  let $_interaction;
  let $_events;
  let $theme;
  let $_iClass;
  let $height;
  let $view;
  let $_viewComponent;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Calendar", slots, []);
  let { plugins = [] } = $$props;
  let { options = {} } = $$props;
  let component = get_current_component();
  let state = new state_default(plugins, options);
  setContext("state", state);
  let { _viewComponent, _bodyEl, _interaction, _iClass, _events, _queue, _queue2, _tasks, _scrollable, height: height2, theme, view: view2 } = state;
  validate_store(_viewComponent, "_viewComponent");
  component_subscribe($$self, _viewComponent, (value) => $$invalidate(5, $_viewComponent = value));
  validate_store(_bodyEl, "_bodyEl");
  component_subscribe($$self, _bodyEl, (value) => $$invalidate(32, $_bodyEl = value));
  validate_store(_interaction, "_interaction");
  component_subscribe($$self, _interaction, (value) => $$invalidate(35, $_interaction = value));
  validate_store(_iClass, "_iClass");
  component_subscribe($$self, _iClass, (value) => $$invalidate(2, $_iClass = value));
  validate_store(_events, "_events");
  component_subscribe($$self, _events, (value) => $$invalidate(36, $_events = value));
  validate_store(_queue, "_queue");
  component_subscribe($$self, _queue, (value) => $$invalidate(34, $_queue = value));
  validate_store(_queue2, "_queue2");
  component_subscribe($$self, _queue2, (value) => $$invalidate(33, $_queue2 = value));
  validate_store(_scrollable, "_scrollable");
  component_subscribe($$self, _scrollable, (value) => $$invalidate(0, $_scrollable = value));
  validate_store(height2, "height");
  component_subscribe($$self, height2, (value) => $$invalidate(3, $height = value));
  validate_store(theme, "theme");
  component_subscribe($$self, theme, (value) => $$invalidate(1, $theme = value));
  validate_store(view2, "view");
  component_subscribe($$self, view2, (value) => $$invalidate(4, $view = value));
  let prevOptions = { ...options };
  function setOption(name, value) {
    state._set(name, value);
    return this;
  }
  function getOption(name) {
    let value = state._get(name);
    return value instanceof Date ? toLocalDate(value) : value;
  }
  function refetchEvents() {
    state._fetchedRange.set({ start: void 0, end: void 0 });
    return this;
  }
  function getEvents() {
    return $_events.map(toEventWithLocalDates);
  }
  function getEventById(id) {
    for (let event of $_events) {
      if (event.id == id) {
        return toEventWithLocalDates(event);
      }
    }
    return null;
  }
  function addEvent(event) {
    $_events.push(createEvents([event])[0]);
    _events.set($_events);
    return this;
  }
  function updateEvent(event) {
    for (let e of $_events) {
      if (e.id == event.id) {
        assign(e, createEvents([event])[0]);
        _events.set($_events);
        break;
      }
    }
    return this;
  }
  function removeEventById(id) {
    let idx = $_events.findIndex((event) => event.id == id);
    if (idx >= 0) {
      $_events.splice(idx, 1);
      _events.set($_events);
    }
    return this;
  }
  function getView() {
    return toViewWithLocalDates(get_store_value(state._view));
  }
  function unselect() {
    if ($_interaction.action) {
      $_interaction.action.unselect();
    }
    return this;
  }
  function dateFromPoint(x, y) {
    let dayEl = getElementWithPayload(x, y);
    return dayEl ? getPayload(dayEl)(x, y) : null;
  }
  function destroy() {
    destroy_component(component, true);
  }
  beforeUpdate(() => {
    flushDebounce($_queue);
  });
  afterUpdate(() => {
    flushDebounce($_queue2);
    task(recheckScrollable, null, _tasks);
  });
  function recheckScrollable() {
    if ($_bodyEl) {
      set_store_value(_scrollable, $_scrollable = hasYScroll($_bodyEl), $_scrollable);
    }
  }
  const writable_props = ["plugins", "options"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Calendar> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("plugins" in $$props2)
      $$invalidate(18, plugins = $$props2.plugins);
    if ("options" in $$props2)
      $$invalidate(19, options = $$props2.options);
  };
  $$self.$capture_state = () => ({
    setContext,
    beforeUpdate,
    afterUpdate,
    destroy_component,
    get_current_component,
    get: get_store_value,
    diff,
    State: state_default,
    Toolbar: Toolbar_default,
    Auxiliary: Auxiliary_default,
    assign,
    createEvents,
    toEventWithLocalDates,
    toViewWithLocalDates,
    toLocalDate,
    getElementWithPayload,
    getPayload,
    flushDebounce,
    hasYScroll,
    listView,
    task,
    plugins,
    options,
    component,
    state,
    _viewComponent,
    _bodyEl,
    _interaction,
    _iClass,
    _events,
    _queue,
    _queue2,
    _tasks,
    _scrollable,
    height: height2,
    theme,
    view: view2,
    prevOptions,
    setOption,
    getOption,
    refetchEvents,
    getEvents,
    getEventById,
    addEvent,
    updateEvent,
    removeEventById,
    getView,
    unselect,
    dateFromPoint,
    destroy,
    recheckScrollable,
    $_bodyEl,
    $_scrollable,
    $_queue2,
    $_queue,
    $_interaction,
    $_events,
    $theme,
    $_iClass,
    $height,
    $view,
    $_viewComponent
  });
  $$self.$inject_state = ($$props2) => {
    if ("plugins" in $$props2)
      $$invalidate(18, plugins = $$props2.plugins);
    if ("options" in $$props2)
      $$invalidate(19, options = $$props2.options);
    if ("component" in $$props2)
      component = $$props2.component;
    if ("state" in $$props2)
      state = $$props2.state;
    if ("_viewComponent" in $$props2)
      $$invalidate(6, _viewComponent = $$props2._viewComponent);
    if ("_bodyEl" in $$props2)
      $$invalidate(7, _bodyEl = $$props2._bodyEl);
    if ("_interaction" in $$props2)
      $$invalidate(8, _interaction = $$props2._interaction);
    if ("_iClass" in $$props2)
      $$invalidate(9, _iClass = $$props2._iClass);
    if ("_events" in $$props2)
      $$invalidate(10, _events = $$props2._events);
    if ("_queue" in $$props2)
      $$invalidate(11, _queue = $$props2._queue);
    if ("_queue2" in $$props2)
      $$invalidate(12, _queue2 = $$props2._queue2);
    if ("_tasks" in $$props2)
      _tasks = $$props2._tasks;
    if ("_scrollable" in $$props2)
      $$invalidate(13, _scrollable = $$props2._scrollable);
    if ("height" in $$props2)
      $$invalidate(14, height2 = $$props2.height);
    if ("theme" in $$props2)
      $$invalidate(15, theme = $$props2.theme);
    if ("view" in $$props2)
      $$invalidate(16, view2 = $$props2.view);
    if ("prevOptions" in $$props2)
      $$invalidate(40, prevOptions = $$props2.prevOptions);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*options*/
    524288) {
      $:
        for (let [name, value] of diff(options, prevOptions)) {
          setOption(name, value);
        }
    }
  };
  return [
    $_scrollable,
    $theme,
    $_iClass,
    $height,
    $view,
    $_viewComponent,
    _viewComponent,
    _bodyEl,
    _interaction,
    _iClass,
    _events,
    _queue,
    _queue2,
    _scrollable,
    height2,
    theme,
    view2,
    recheckScrollable,
    plugins,
    options,
    setOption,
    getOption,
    refetchEvents,
    getEvents,
    getEventById,
    addEvent,
    updateEvent,
    removeEventById,
    getView,
    unselect,
    dateFromPoint,
    destroy
  ];
}
var Calendar = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance4,
      create_fragment4,
      safe_not_equal,
      {
        plugins: 18,
        options: 19,
        setOption: 20,
        getOption: 21,
        refetchEvents: 22,
        getEvents: 23,
        getEventById: 24,
        addEvent: 25,
        updateEvent: 26,
        removeEventById: 27,
        getView: 28,
        unselect: 29,
        dateFromPoint: 30,
        destroy: 31
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Calendar",
      options,
      id: create_fragment4.name
    });
  }
  get plugins() {
    throw new Error("<Calendar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set plugins(value) {
    throw new Error("<Calendar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get options() {
    throw new Error("<Calendar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set options(value) {
    throw new Error("<Calendar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get setOption() {
    return this.$$.ctx[20];
  }
  set setOption(value) {
    throw new Error("<Calendar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getOption() {
    return this.$$.ctx[21];
  }
  set getOption(value) {
    throw new Error("<Calendar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get refetchEvents() {
    return this.$$.ctx[22];
  }
  set refetchEvents(value) {
    throw new Error("<Calendar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getEvents() {
    return this.$$.ctx[23];
  }
  set getEvents(value) {
    throw new Error("<Calendar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getEventById() {
    return this.$$.ctx[24];
  }
  set getEventById(value) {
    throw new Error("<Calendar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get addEvent() {
    return this.$$.ctx[25];
  }
  set addEvent(value) {
    throw new Error("<Calendar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get updateEvent() {
    return this.$$.ctx[26];
  }
  set updateEvent(value) {
    throw new Error("<Calendar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get removeEventById() {
    return this.$$.ctx[27];
  }
  set removeEventById(value) {
    throw new Error("<Calendar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getView() {
    return this.$$.ctx[28];
  }
  set getView(value) {
    throw new Error("<Calendar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get unselect() {
    return this.$$.ctx[29];
  }
  set unselect(value) {
    throw new Error("<Calendar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dateFromPoint() {
    return this.$$.ctx[30];
  }
  set dateFromPoint(value) {
    throw new Error("<Calendar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get destroy() {
    return this.$$.ctx[31];
  }
  set destroy(value) {
    throw new Error("<Calendar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Calendar_default = Calendar;

export {
  keyEnter,
  setContent,
  outsideEvent,
  DAY_IN_SECONDS,
  createDate,
  createDuration,
  cloneDate,
  addDuration,
  subtractDuration,
  addDay,
  subtractDay,
  setMidnight,
  toLocalDate,
  toISOString,
  datesEqual,
  nextClosestDay,
  prevClosestDay,
  noTimePart,
  copyTime,
  toSeconds,
  debounce,
  flushDebounce,
  task,
  assign,
  keys,
  floor,
  ceil,
  min,
  max,
  symbol,
  createElement,
  hasYScroll,
  rect,
  ancestor,
  height,
  setPayload,
  hasPayload,
  getPayload,
  getElementWithPayload,
  createView,
  toViewWithLocalDates,
  listView,
  timelineView,
  createEvents,
  createEventSources,
  createEventChunk,
  sortEventChunks,
  createEventContent,
  createEventClasses,
  toEventWithLocalDates,
  cloneEvent,
  prepareEventChunks,
  repositionEvent,
  runReposition,
  eventIntersects,
  helperEvent,
  bgEvent,
  previewEvent,
  ghostEvent,
  pointerEvent,
  btnTextDay,
  btnTextWeek,
  btnTextMonth,
  btnTextYear,
  themeView,
  intl,
  intlRange,
  createTimes,
  createSlotTimeLimits,
  Calendar_default
};
//# sourceMappingURL=chunk-7NNYD6EP.js.map
